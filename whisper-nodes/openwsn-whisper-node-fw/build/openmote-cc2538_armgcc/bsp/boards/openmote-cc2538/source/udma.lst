   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"udma.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.align	2
  20              		.global	uDMAEnable
  21              		.thumb
  22              		.thumb_func
  24              	uDMAEnable:
  25              	.LFB0:
  26              		.file 1 "build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c"
   1:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** /******************************************************************************
   2:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  Filename:       udma.c
   3:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  Revised:        $Date: 2013-03-20 14:47:53 +0100 (Wed, 20 Mar 2013) $
   4:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  Revision:       $Revision: 9489 $
   5:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *
   6:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  Description:    Driver for the micro-DMA controller.
   7:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *
   8:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
   9:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *
  10:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *
  11:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  Redistribution and use in source and binary forms, with or without
  12:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  modification, are permitted provided that the following conditions
  13:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  are met:
  14:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *
  15:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *    Redistributions of source code must retain the above copyright
  16:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *    notice, this list of conditions and the following disclaimer.
  17:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *
  18:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *    Redistributions in binary form must reproduce the above copyright
  19:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *    notice, this list of conditions and the following disclaimer in the
  20:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *    documentation and/or other materials provided with the distribution.
  21:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *
  22:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *    Neither the name of Texas Instruments Incorporated nor the names of
  23:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *    its contributors may be used to endorse or promote products derived
  24:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *    from this software without specific prior written permission.
  25:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *
  26:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  27:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  28:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  29:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  30:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  31:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  32:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  33:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  34:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  35:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  36:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  37:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** *
  38:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** ******************************************************************************/
  39:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
  40:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
  41:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
  42:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \addtogroup udma_api
  43:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! @{
  44:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
  45:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
  46:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
  47:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** #include <headers/hw_sys_ctrl.h>
  48:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** #include <headers/hw_udma.h>
  49:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** #include <headers/hw_udmachctl.h>
  50:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** #include "debug.h"
  51:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** #include "interrupt.h"
  52:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** #include "udma.h"
  53:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
  54:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
  55:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
  56:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Enables the uDMA controller for use
  57:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
  58:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function enables the uDMA controller.  The uDMA controller must be
  59:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! enabled before it can be configured and used.
  60:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
  61:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
  62:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
  63:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
  64:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
  65:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAEnable(void)
  66:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
  27              		.loc 1 66 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 80B4     		push	{r7}
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 7, -4
  35 0002 00AF     		add	r7, sp, #0
  36              		.cfi_def_cfa_register 7
  67:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
  68:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Set the master enable bit in the config register.
  69:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
  70:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     HWREG(UDMA_CFG) = UDMA_CFG_MASTEN;
  37              		.loc 1 70 0
  38 0004 034B     		ldr	r3, .L2
  39 0006 0122     		movs	r2, #1
  40 0008 1A60     		str	r2, [r3]
  71:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
  41              		.loc 1 71 0
  42 000a 00BF     		nop
  43 000c BD46     		mov	sp, r7
  44              		.cfi_def_cfa_register 13
  45              		@ sp needed
  46 000e 80BC     		pop	{r7}
  47              		.cfi_restore 7
  48              		.cfi_def_cfa_offset 0
  49 0010 7047     		bx	lr
  50              	.L3:
  51 0012 00BF     		.align	2
  52              	.L2:
  53 0014 04F00F40 		.word	1074786308
  54              		.cfi_endproc
  55              	.LFE0:
  57              		.align	2
  58              		.global	uDMADisable
  59              		.thumb
  60              		.thumb_func
  62              	uDMADisable:
  63              	.LFB1:
  72:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
  73:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
  74:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
  75:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Disables the uDMA controller for use
  76:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
  77:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function disables the uDMA controller.  Once disabled, the uDMA
  78:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! controller will not operate until re-enabled with uDMAEnable().
  79:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
  80:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
  81:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
  82:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
  83:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
  84:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMADisable(void)
  85:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
  64              		.loc 1 85 0
  65              		.cfi_startproc
  66              		@ args = 0, pretend = 0, frame = 0
  67              		@ frame_needed = 1, uses_anonymous_args = 0
  68              		@ link register save eliminated.
  69 0018 80B4     		push	{r7}
  70              		.cfi_def_cfa_offset 4
  71              		.cfi_offset 7, -4
  72 001a 00AF     		add	r7, sp, #0
  73              		.cfi_def_cfa_register 7
  86:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
  87:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Clear the master enable bit in the config register.
  88:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
  89:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     HWREG(UDMA_CFG) = 0;
  74              		.loc 1 89 0
  75 001c 034B     		ldr	r3, .L5
  76 001e 0022     		movs	r2, #0
  77 0020 1A60     		str	r2, [r3]
  90:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
  78              		.loc 1 90 0
  79 0022 00BF     		nop
  80 0024 BD46     		mov	sp, r7
  81              		.cfi_def_cfa_register 13
  82              		@ sp needed
  83 0026 80BC     		pop	{r7}
  84              		.cfi_restore 7
  85              		.cfi_def_cfa_offset 0
  86 0028 7047     		bx	lr
  87              	.L6:
  88 002a 00BF     		.align	2
  89              	.L5:
  90 002c 04F00F40 		.word	1074786308
  91              		.cfi_endproc
  92              	.LFE1:
  94              		.align	2
  95              		.global	uDMAErrorStatusGet
  96              		.thumb
  97              		.thumb_func
  99              	uDMAErrorStatusGet:
 100              	.LFB2:
  91:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
  92:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
  93:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
  94:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Gets the uDMA error status
  95:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
  96:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function returns the uDMA error status.  It should be called from
  97:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! within the uDMA error interrupt handler to determine if a uDMA error
  98:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! occurred.
  99:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 100:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return Returns non-zero if a uDMA error is pending.
 101:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 102:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 103:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uint32_t
 104:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAErrorStatusGet(void)
 105:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 101              		.loc 1 105 0
 102              		.cfi_startproc
 103              		@ args = 0, pretend = 0, frame = 0
 104              		@ frame_needed = 1, uses_anonymous_args = 0
 105              		@ link register save eliminated.
 106 0030 80B4     		push	{r7}
 107              		.cfi_def_cfa_offset 4
 108              		.cfi_offset 7, -4
 109 0032 00AF     		add	r7, sp, #0
 110              		.cfi_def_cfa_register 7
 106:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 107:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Return the uDMA error status.
 108:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 109:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     return(HWREG(UDMA_ERRCLR));
 111              		.loc 1 109 0
 112 0034 024B     		ldr	r3, .L9
 113 0036 1B68     		ldr	r3, [r3]
 110:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 114              		.loc 1 110 0
 115 0038 1846     		mov	r0, r3
 116 003a BD46     		mov	sp, r7
 117              		.cfi_def_cfa_register 13
 118              		@ sp needed
 119 003c 80BC     		pop	{r7}
 120              		.cfi_restore 7
 121              		.cfi_def_cfa_offset 0
 122 003e 7047     		bx	lr
 123              	.L10:
 124              		.align	2
 125              	.L9:
 126 0040 4CF00F40 		.word	1074786380
 127              		.cfi_endproc
 128              	.LFE2:
 130              		.align	2
 131              		.global	uDMAErrorStatusClear
 132              		.thumb
 133              		.thumb_func
 135              	uDMAErrorStatusClear:
 136              	.LFB3:
 111:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 112:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 113:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 114:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Clears the uDMA error interrupt
 115:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 116:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function clears a pending uDMA error interrupt.  It should be called
 117:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! from within the uDMA error interrupt handler to clear the interrupt.
 118:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 119:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
 120:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 121:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 122:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
 123:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAErrorStatusClear(void)
 124:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 137              		.loc 1 124 0
 138              		.cfi_startproc
 139              		@ args = 0, pretend = 0, frame = 0
 140              		@ frame_needed = 1, uses_anonymous_args = 0
 141              		@ link register save eliminated.
 142 0044 80B4     		push	{r7}
 143              		.cfi_def_cfa_offset 4
 144              		.cfi_offset 7, -4
 145 0046 00AF     		add	r7, sp, #0
 146              		.cfi_def_cfa_register 7
 125:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 126:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Clear the uDMA error interrupt.
 127:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 128:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     HWREG(UDMA_ERRCLR) = 1;
 147              		.loc 1 128 0
 148 0048 034B     		ldr	r3, .L12
 149 004a 0122     		movs	r2, #1
 150 004c 1A60     		str	r2, [r3]
 129:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 151              		.loc 1 129 0
 152 004e 00BF     		nop
 153 0050 BD46     		mov	sp, r7
 154              		.cfi_def_cfa_register 13
 155              		@ sp needed
 156 0052 80BC     		pop	{r7}
 157              		.cfi_restore 7
 158              		.cfi_def_cfa_offset 0
 159 0054 7047     		bx	lr
 160              	.L13:
 161 0056 00BF     		.align	2
 162              	.L12:
 163 0058 4CF00F40 		.word	1074786380
 164              		.cfi_endproc
 165              	.LFE3:
 167              		.align	2
 168              		.global	uDMAChannelEnable
 169              		.thumb
 170              		.thumb_func
 172              	uDMAChannelEnable:
 173              	.LFB4:
 130:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 131:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 132:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 133:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Enables a uDMA channel for operation
 134:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 135:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelNum is the channel number to enable.
 136:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 137:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function enables a specific uDMA channel for use.  This function must
 138:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! be used to enable a channel before it can be used to perform a uDMA
 139:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! transfer.
 140:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 141:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! When a uDMA transfer is completed, the channel will be automatically
 142:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! disabled by the uDMA controller.  Therefore, this function should be called
 143:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! prior to starting up any new transfer.
 144:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 145:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
 146:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 147:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 148:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
 149:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelEnable(uint32_t ui32ChannelNum)
 150:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 174              		.loc 1 150 0
 175              		.cfi_startproc
 176              		@ args = 0, pretend = 0, frame = 8
 177              		@ frame_needed = 1, uses_anonymous_args = 0
 178              		@ link register save eliminated.
 179 005c 80B4     		push	{r7}
 180              		.cfi_def_cfa_offset 4
 181              		.cfi_offset 7, -4
 182 005e 83B0     		sub	sp, sp, #12
 183              		.cfi_def_cfa_offset 16
 184 0060 00AF     		add	r7, sp, #0
 185              		.cfi_def_cfa_register 7
 186 0062 7860     		str	r0, [r7, #4]
 151:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 152:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
 153:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 154:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 155:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 156:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 157:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Set the bit for this channel in the enable set register.
 158:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 159:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     HWREG(UDMA_ENASET) = 1 << (ui32ChannelNum & 0x1f);
 187              		.loc 1 159 0
 188 0064 064A     		ldr	r2, .L15
 189 0066 7B68     		ldr	r3, [r7, #4]
 190 0068 03F01F03 		and	r3, r3, #31
 191 006c 0121     		movs	r1, #1
 192 006e 01FA03F3 		lsl	r3, r1, r3
 193 0072 1360     		str	r3, [r2]
 160:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 194              		.loc 1 160 0
 195 0074 00BF     		nop
 196 0076 0C37     		adds	r7, r7, #12
 197              		.cfi_def_cfa_offset 4
 198 0078 BD46     		mov	sp, r7
 199              		.cfi_def_cfa_register 13
 200              		@ sp needed
 201 007a 80BC     		pop	{r7}
 202              		.cfi_restore 7
 203              		.cfi_def_cfa_offset 0
 204 007c 7047     		bx	lr
 205              	.L16:
 206 007e 00BF     		.align	2
 207              	.L15:
 208 0080 28F00F40 		.word	1074786344
 209              		.cfi_endproc
 210              	.LFE4:
 212              		.align	2
 213              		.global	uDMAChannelDisable
 214              		.thumb
 215              		.thumb_func
 217              	uDMAChannelDisable:
 218              	.LFB5:
 161:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 162:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 163:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 164:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Disables a uDMA channel for operation
 165:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 166:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelNum is the channel number to disable.
 167:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 168:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function disables a specific uDMA channel.  Once disabled, a channel
 169:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! will not respond to uDMA transfer requests until re-enabled via
 170:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! uDMAChannelEnable().
 171:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 172:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
 173:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 174:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 175:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
 176:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelDisable(uint32_t ui32ChannelNum)
 177:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 219              		.loc 1 177 0
 220              		.cfi_startproc
 221              		@ args = 0, pretend = 0, frame = 8
 222              		@ frame_needed = 1, uses_anonymous_args = 0
 223              		@ link register save eliminated.
 224 0084 80B4     		push	{r7}
 225              		.cfi_def_cfa_offset 4
 226              		.cfi_offset 7, -4
 227 0086 83B0     		sub	sp, sp, #12
 228              		.cfi_def_cfa_offset 16
 229 0088 00AF     		add	r7, sp, #0
 230              		.cfi_def_cfa_register 7
 231 008a 7860     		str	r0, [r7, #4]
 178:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 179:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
 180:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 181:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 182:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 183:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 184:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Set the bit for this channel in the enable clear register.
 185:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 186:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     HWREG(UDMA_ENACLR) = 1 << (ui32ChannelNum & 0x1f);
 232              		.loc 1 186 0
 233 008c 064A     		ldr	r2, .L18
 234 008e 7B68     		ldr	r3, [r7, #4]
 235 0090 03F01F03 		and	r3, r3, #31
 236 0094 0121     		movs	r1, #1
 237 0096 01FA03F3 		lsl	r3, r1, r3
 238 009a 1360     		str	r3, [r2]
 187:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 239              		.loc 1 187 0
 240 009c 00BF     		nop
 241 009e 0C37     		adds	r7, r7, #12
 242              		.cfi_def_cfa_offset 4
 243 00a0 BD46     		mov	sp, r7
 244              		.cfi_def_cfa_register 13
 245              		@ sp needed
 246 00a2 80BC     		pop	{r7}
 247              		.cfi_restore 7
 248              		.cfi_def_cfa_offset 0
 249 00a4 7047     		bx	lr
 250              	.L19:
 251 00a6 00BF     		.align	2
 252              	.L18:
 253 00a8 2CF00F40 		.word	1074786348
 254              		.cfi_endproc
 255              	.LFE5:
 257              		.align	2
 258              		.global	uDMAChannelIsEnabled
 259              		.thumb
 260              		.thumb_func
 262              	uDMAChannelIsEnabled:
 263              	.LFB6:
 188:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 189:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 190:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 191:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Checks if a uDMA channel is enabled for operation
 192:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 193:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelNum is the channel number to check.
 194:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 195:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function checks to see if a specific uDMA channel is enabled.  This
 196:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! can be used to check the status of a transfer, since the channel will
 197:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! be automatically disabled at the end of a transfer.
 198:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 199:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return Returns \b true if the channel is enabled, \b false if disabled.
 200:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 201:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 202:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** bool
 203:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelIsEnabled(uint32_t ui32ChannelNum)
 204:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 264              		.loc 1 204 0
 265              		.cfi_startproc
 266              		@ args = 0, pretend = 0, frame = 8
 267              		@ frame_needed = 1, uses_anonymous_args = 0
 268              		@ link register save eliminated.
 269 00ac 80B4     		push	{r7}
 270              		.cfi_def_cfa_offset 4
 271              		.cfi_offset 7, -4
 272 00ae 83B0     		sub	sp, sp, #12
 273              		.cfi_def_cfa_offset 16
 274 00b0 00AF     		add	r7, sp, #0
 275              		.cfi_def_cfa_register 7
 276 00b2 7860     		str	r0, [r7, #4]
 205:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 206:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
 207:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 208:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 209:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 210:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 211:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // AND the specified channel bit with the enable register, and return the
 212:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // result.
 213:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 214:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 215:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     return((HWREG(UDMA_ENASET) & (1 << (ui32ChannelNum & 0x1f))) ? true : false);
 277              		.loc 1 215 0
 278 00b4 094B     		ldr	r3, .L22
 279 00b6 1B68     		ldr	r3, [r3]
 280 00b8 7A68     		ldr	r2, [r7, #4]
 281 00ba 02F01F02 		and	r2, r2, #31
 282 00be 0121     		movs	r1, #1
 283 00c0 01FA02F2 		lsl	r2, r1, r2
 284 00c4 1340     		ands	r3, r3, r2
 285 00c6 002B     		cmp	r3, #0
 286 00c8 14BF     		ite	ne
 287 00ca 0123     		movne	r3, #1
 288 00cc 0023     		moveq	r3, #0
 289 00ce DBB2     		uxtb	r3, r3
 216:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 290              		.loc 1 216 0
 291 00d0 1846     		mov	r0, r3
 292 00d2 0C37     		adds	r7, r7, #12
 293              		.cfi_def_cfa_offset 4
 294 00d4 BD46     		mov	sp, r7
 295              		.cfi_def_cfa_register 13
 296              		@ sp needed
 297 00d6 80BC     		pop	{r7}
 298              		.cfi_restore 7
 299              		.cfi_def_cfa_offset 0
 300 00d8 7047     		bx	lr
 301              	.L23:
 302 00da 00BF     		.align	2
 303              	.L22:
 304 00dc 28F00F40 		.word	1074786344
 305              		.cfi_endproc
 306              	.LFE6:
 308              		.align	2
 309              		.global	uDMAControlBaseSet
 310              		.thumb
 311              		.thumb_func
 313              	uDMAControlBaseSet:
 314              	.LFB7:
 217:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 218:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 219:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 220:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Sets the base address for the channel control table
 221:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 222:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param pControlTable is a pointer to the 1024 byte aligned base address
 223:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! of the uDMA channel control table.
 224:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 225:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function sets the base address of the channel control table.  This
 226:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! table resides in system memory and holds control information for each uDMA
 227:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! channel.  The table must be aligned on a 1024 byte boundary.  The base
 228:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! address must be set before any of the channel functions can be used.
 229:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 230:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The size of the channel control table depends on the number of uDMA
 231:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! channels, and which transfer modes are used.  Refer to the introductory
 232:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! text and the microcontroller datasheet for more information about the
 233:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! channel control table.
 234:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 235:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
 236:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 237:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 238:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
 239:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAControlBaseSet(void *pControlTable)
 240:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 315              		.loc 1 240 0
 316              		.cfi_startproc
 317              		@ args = 0, pretend = 0, frame = 8
 318              		@ frame_needed = 1, uses_anonymous_args = 0
 319              		@ link register save eliminated.
 320 00e0 80B4     		push	{r7}
 321              		.cfi_def_cfa_offset 4
 322              		.cfi_offset 7, -4
 323 00e2 83B0     		sub	sp, sp, #12
 324              		.cfi_def_cfa_offset 16
 325 00e4 00AF     		add	r7, sp, #0
 326              		.cfi_def_cfa_register 7
 327 00e6 7860     		str	r0, [r7, #4]
 241:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 242:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
 243:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 244:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT(((uint32_t)pControlTable & ~0x3FF) ==
 245:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****            (uint32_t)pControlTable);
 246:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((uint32_t)pControlTable >= 0x20000000);
 247:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 248:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 249:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Program the base address into the register.
 250:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 251:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     HWREG(UDMA_CTLBASE) = (uint32_t)pControlTable;
 328              		.loc 1 251 0
 329 00e8 034A     		ldr	r2, .L25
 330 00ea 7B68     		ldr	r3, [r7, #4]
 331 00ec 1360     		str	r3, [r2]
 252:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 332              		.loc 1 252 0
 333 00ee 00BF     		nop
 334 00f0 0C37     		adds	r7, r7, #12
 335              		.cfi_def_cfa_offset 4
 336 00f2 BD46     		mov	sp, r7
 337              		.cfi_def_cfa_register 13
 338              		@ sp needed
 339 00f4 80BC     		pop	{r7}
 340              		.cfi_restore 7
 341              		.cfi_def_cfa_offset 0
 342 00f6 7047     		bx	lr
 343              	.L26:
 344              		.align	2
 345              	.L25:
 346 00f8 08F00F40 		.word	1074786312
 347              		.cfi_endproc
 348              	.LFE7:
 350              		.align	2
 351              		.global	uDMAControlBaseGet
 352              		.thumb
 353              		.thumb_func
 355              	uDMAControlBaseGet:
 356              	.LFB8:
 253:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 254:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 255:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 256:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Gets the base address for the channel control table
 257:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 258:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function gets the base address of the channel control table.  This
 259:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! table resides in system memory and holds control information for each uDMA
 260:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! channel.
 261:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 262:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return Returns a pointer to the base address of the channel control table.
 263:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 264:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 265:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void *
 266:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAControlBaseGet(void)
 267:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 357              		.loc 1 267 0
 358              		.cfi_startproc
 359              		@ args = 0, pretend = 0, frame = 0
 360              		@ frame_needed = 1, uses_anonymous_args = 0
 361              		@ link register save eliminated.
 362 00fc 80B4     		push	{r7}
 363              		.cfi_def_cfa_offset 4
 364              		.cfi_offset 7, -4
 365 00fe 00AF     		add	r7, sp, #0
 366              		.cfi_def_cfa_register 7
 268:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 269:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Read the current value of the control base register, and return it to
 270:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // the caller.
 271:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 272:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     return((void *)HWREG(UDMA_CTLBASE));
 367              		.loc 1 272 0
 368 0100 024B     		ldr	r3, .L29
 369 0102 1B68     		ldr	r3, [r3]
 273:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 370              		.loc 1 273 0
 371 0104 1846     		mov	r0, r3
 372 0106 BD46     		mov	sp, r7
 373              		.cfi_def_cfa_register 13
 374              		@ sp needed
 375 0108 80BC     		pop	{r7}
 376              		.cfi_restore 7
 377              		.cfi_def_cfa_offset 0
 378 010a 7047     		bx	lr
 379              	.L30:
 380              		.align	2
 381              	.L29:
 382 010c 08F00F40 		.word	1074786312
 383              		.cfi_endproc
 384              	.LFE8:
 386              		.align	2
 387              		.global	uDMAControlAlternateBaseGet
 388              		.thumb
 389              		.thumb_func
 391              	uDMAControlAlternateBaseGet:
 392              	.LFB9:
 274:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 275:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 276:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 277:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Gets the base address for the channel control table alternate structures
 278:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 279:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function gets the base address of the second half of the channel
 280:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! control table that holds the alternate control structures for each channel.
 281:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 282:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return Returns a pointer to the base address of the second half of the
 283:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! channel control table.
 284:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 285:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 286:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void *
 287:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAControlAlternateBaseGet(void)
 288:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 393              		.loc 1 288 0
 394              		.cfi_startproc
 395              		@ args = 0, pretend = 0, frame = 0
 396              		@ frame_needed = 1, uses_anonymous_args = 0
 397              		@ link register save eliminated.
 398 0110 80B4     		push	{r7}
 399              		.cfi_def_cfa_offset 4
 400              		.cfi_offset 7, -4
 401 0112 00AF     		add	r7, sp, #0
 402              		.cfi_def_cfa_register 7
 289:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 290:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Read the current value of the control base register, and return it to
 291:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // the caller.
 292:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 293:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     return((void *)HWREG(UDMA_ALTBASE));
 403              		.loc 1 293 0
 404 0114 024B     		ldr	r3, .L33
 405 0116 1B68     		ldr	r3, [r3]
 294:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 406              		.loc 1 294 0
 407 0118 1846     		mov	r0, r3
 408 011a BD46     		mov	sp, r7
 409              		.cfi_def_cfa_register 13
 410              		@ sp needed
 411 011c 80BC     		pop	{r7}
 412              		.cfi_restore 7
 413              		.cfi_def_cfa_offset 0
 414 011e 7047     		bx	lr
 415              	.L34:
 416              		.align	2
 417              	.L33:
 418 0120 0CF00F40 		.word	1074786316
 419              		.cfi_endproc
 420              	.LFE9:
 422              		.align	2
 423              		.global	uDMAChannelRequest
 424              		.thumb
 425              		.thumb_func
 427              	uDMAChannelRequest:
 428              	.LFB10:
 295:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 296:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 297:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 298:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Requests a uDMA channel to start a transfer
 299:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 300:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelNum is the channel number on which to request a uDMA
 301:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! transfer.
 302:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 303:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function allows software to request a uDMA channel to begin a
 304:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! transfer.  This could be used for performing a memory to memory transfer,
 305:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! or if for some reason a transfer needs to be initiated by software instead
 306:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! of the peripheral associated with that channel.
 307:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 308:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \note If the channel is \b UDMA_CH30_SW and interrupts
 309:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! are used, then the completion will be signaled on the uDMA dedicated
 310:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! interrupt.
 311:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! If a peripheral channel is used, then the completion will be signaled on the
 312:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! peripheral's interrupt.
 313:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 314:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
 315:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 316:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 317:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
 318:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelRequest(uint32_t ui32ChannelNum)
 319:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 429              		.loc 1 319 0
 430              		.cfi_startproc
 431              		@ args = 0, pretend = 0, frame = 8
 432              		@ frame_needed = 1, uses_anonymous_args = 0
 433              		@ link register save eliminated.
 434 0124 80B4     		push	{r7}
 435              		.cfi_def_cfa_offset 4
 436              		.cfi_offset 7, -4
 437 0126 83B0     		sub	sp, sp, #12
 438              		.cfi_def_cfa_offset 16
 439 0128 00AF     		add	r7, sp, #0
 440              		.cfi_def_cfa_register 7
 441 012a 7860     		str	r0, [r7, #4]
 320:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 321:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
 322:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 323:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 324:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 325:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 326:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Set the bit for this channel in the software uDMA request register.
 327:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 328:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     HWREG(UDMA_SWREQ) = 1 << (ui32ChannelNum & 0x1f);
 442              		.loc 1 328 0
 443 012c 064A     		ldr	r2, .L36
 444 012e 7B68     		ldr	r3, [r7, #4]
 445 0130 03F01F03 		and	r3, r3, #31
 446 0134 0121     		movs	r1, #1
 447 0136 01FA03F3 		lsl	r3, r1, r3
 448 013a 1360     		str	r3, [r2]
 329:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 449              		.loc 1 329 0
 450 013c 00BF     		nop
 451 013e 0C37     		adds	r7, r7, #12
 452              		.cfi_def_cfa_offset 4
 453 0140 BD46     		mov	sp, r7
 454              		.cfi_def_cfa_register 13
 455              		@ sp needed
 456 0142 80BC     		pop	{r7}
 457              		.cfi_restore 7
 458              		.cfi_def_cfa_offset 0
 459 0144 7047     		bx	lr
 460              	.L37:
 461 0146 00BF     		.align	2
 462              	.L36:
 463 0148 14F00F40 		.word	1074786324
 464              		.cfi_endproc
 465              	.LFE10:
 467              		.align	2
 468              		.global	uDMAChannelAttributeEnable
 469              		.thumb
 470              		.thumb_func
 472              	uDMAChannelAttributeEnable:
 473              	.LFB11:
 330:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 331:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 332:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 333:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Enables attributes of a uDMA channel
 334:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 335:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelNum is the channel to configure.
 336:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32Attr is a combination of attributes for the channel.
 337:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 338:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function is used to enable attributes of a uDMA channel.
 339:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 340:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The \e ui32Attr parameter is the logical OR of any of the following:
 341:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 342:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only a burst
 343:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   mode.
 344:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
 345:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   for this channel (it is very unlikely that this flag should be used).
 346:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
 347:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
 348:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   peripheral for this channel.
 349:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 350:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
 351:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 352:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 353:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
 354:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelAttributeEnable(uint32_t ui32ChannelNum, uint32_t ui32Attr)
 355:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 474              		.loc 1 355 0
 475              		.cfi_startproc
 476              		@ args = 0, pretend = 0, frame = 8
 477              		@ frame_needed = 1, uses_anonymous_args = 0
 478              		@ link register save eliminated.
 479 014c 80B4     		push	{r7}
 480              		.cfi_def_cfa_offset 4
 481              		.cfi_offset 7, -4
 482 014e 83B0     		sub	sp, sp, #12
 483              		.cfi_def_cfa_offset 16
 484 0150 00AF     		add	r7, sp, #0
 485              		.cfi_def_cfa_register 7
 486 0152 7860     		str	r0, [r7, #4]
 487 0154 3960     		str	r1, [r7]
 356:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 357:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
 358:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 359:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 360:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32Attr & ~(UDMA_ATTR_USEBURST | UDMA_ATTR_ALTSELECT |
 361:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                          UDMA_ATTR_HIGH_PRIORITY | UDMA_ATTR_REQMASK)) == 0);
 362:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 363:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 364:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 365:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 366:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // from this parameter.
 367:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 368:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32ChannelNum &= 0x1f;
 488              		.loc 1 368 0
 489 0156 7B68     		ldr	r3, [r7, #4]
 490 0158 03F01F03 		and	r3, r3, #31
 491 015c 7B60     		str	r3, [r7, #4]
 369:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 370:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 371:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Set the useburst bit for this channel if set in ui32Config.
 372:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 373:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_USEBURST)
 492              		.loc 1 373 0
 493 015e 3B68     		ldr	r3, [r7]
 494 0160 03F00103 		and	r3, r3, #1
 495 0164 002B     		cmp	r3, #0
 496 0166 05D0     		beq	.L39
 374:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 375:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         HWREG(UDMA_USEBURSTSET) = 1 << ui32ChannelNum;
 497              		.loc 1 375 0
 498 0168 154A     		ldr	r2, .L44
 499 016a 0121     		movs	r1, #1
 500 016c 7B68     		ldr	r3, [r7, #4]
 501 016e 01FA03F3 		lsl	r3, r1, r3
 502 0172 1360     		str	r3, [r2]
 503              	.L39:
 376:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 377:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 378:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 379:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Set the alternate control select bit for this channel,
 380:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // if set in ui32Config.
 381:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 382:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_ALTSELECT)
 504              		.loc 1 382 0
 505 0174 3B68     		ldr	r3, [r7]
 506 0176 03F00203 		and	r3, r3, #2
 507 017a 002B     		cmp	r3, #0
 508 017c 05D0     		beq	.L40
 383:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 384:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         HWREG(UDMA_ALTSET) = 1 << ui32ChannelNum;
 509              		.loc 1 384 0
 510 017e 114A     		ldr	r2, .L44+4
 511 0180 0121     		movs	r1, #1
 512 0182 7B68     		ldr	r3, [r7, #4]
 513 0184 01FA03F3 		lsl	r3, r1, r3
 514 0188 1360     		str	r3, [r2]
 515              	.L40:
 385:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 386:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 387:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 388:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Set the high priority bit for this channel, if set in ui32Config.
 389:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 390:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_HIGH_PRIORITY)
 516              		.loc 1 390 0
 517 018a 3B68     		ldr	r3, [r7]
 518 018c 03F00403 		and	r3, r3, #4
 519 0190 002B     		cmp	r3, #0
 520 0192 05D0     		beq	.L41
 391:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 392:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         HWREG(UDMA_PRIOSET) = 1 << ui32ChannelNum;
 521              		.loc 1 392 0
 522 0194 0C4A     		ldr	r2, .L44+8
 523 0196 0121     		movs	r1, #1
 524 0198 7B68     		ldr	r3, [r7, #4]
 525 019a 01FA03F3 		lsl	r3, r1, r3
 526 019e 1360     		str	r3, [r2]
 527              	.L41:
 393:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 394:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 395:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 396:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Set the request mask bit for this channel, if set in ui32Config.
 397:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 398:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_REQMASK)
 528              		.loc 1 398 0
 529 01a0 3B68     		ldr	r3, [r7]
 530 01a2 03F00803 		and	r3, r3, #8
 531 01a6 002B     		cmp	r3, #0
 532 01a8 05D0     		beq	.L43
 399:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 400:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         HWREG(UDMA_REQMASKSET) = 1 << ui32ChannelNum;
 533              		.loc 1 400 0
 534 01aa 084A     		ldr	r2, .L44+12
 535 01ac 0121     		movs	r1, #1
 536 01ae 7B68     		ldr	r3, [r7, #4]
 537 01b0 01FA03F3 		lsl	r3, r1, r3
 538 01b4 1360     		str	r3, [r2]
 539              	.L43:
 401:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 402:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 540              		.loc 1 402 0
 541 01b6 00BF     		nop
 542 01b8 0C37     		adds	r7, r7, #12
 543              		.cfi_def_cfa_offset 4
 544 01ba BD46     		mov	sp, r7
 545              		.cfi_def_cfa_register 13
 546              		@ sp needed
 547 01bc 80BC     		pop	{r7}
 548              		.cfi_restore 7
 549              		.cfi_def_cfa_offset 0
 550 01be 7047     		bx	lr
 551              	.L45:
 552              		.align	2
 553              	.L44:
 554 01c0 18F00F40 		.word	1074786328
 555 01c4 30F00F40 		.word	1074786352
 556 01c8 38F00F40 		.word	1074786360
 557 01cc 20F00F40 		.word	1074786336
 558              		.cfi_endproc
 559              	.LFE11:
 561              		.align	2
 562              		.global	uDMAChannelAttributeDisable
 563              		.thumb
 564              		.thumb_func
 566              	uDMAChannelAttributeDisable:
 567              	.LFB12:
 403:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 404:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 405:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 406:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Disables attributes of a uDMA channel
 407:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 408:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelNum is the channel to configure.
 409:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32Attr is a combination of attributes for the channel.
 410:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 411:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function is used to disable attributes of a uDMA channel.
 412:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 413:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The \e ui32Attr parameter is the logical OR of any of the following:
 414:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 415:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only a burst
 416:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   mode.
 417:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
 418:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   for this channel.
 419:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
 420:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
 421:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   peripheral for this channel.
 422:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 423:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
 424:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 425:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 426:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
 427:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelAttributeDisable(uint32_t ui32ChannelNum, uint32_t ui32Attr)
 428:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 568              		.loc 1 428 0
 569              		.cfi_startproc
 570              		@ args = 0, pretend = 0, frame = 8
 571              		@ frame_needed = 1, uses_anonymous_args = 0
 572              		@ link register save eliminated.
 573 01d0 80B4     		push	{r7}
 574              		.cfi_def_cfa_offset 4
 575              		.cfi_offset 7, -4
 576 01d2 83B0     		sub	sp, sp, #12
 577              		.cfi_def_cfa_offset 16
 578 01d4 00AF     		add	r7, sp, #0
 579              		.cfi_def_cfa_register 7
 580 01d6 7860     		str	r0, [r7, #4]
 581 01d8 3960     		str	r1, [r7]
 429:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 430:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
 431:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 432:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 433:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32Attr & ~(UDMA_ATTR_USEBURST | UDMA_ATTR_ALTSELECT |
 434:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                          UDMA_ATTR_HIGH_PRIORITY | UDMA_ATTR_REQMASK)) == 0);
 435:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 436:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 437:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 438:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 439:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // from this parameter.
 440:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 441:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32ChannelNum &= 0x1f;
 582              		.loc 1 441 0
 583 01da 7B68     		ldr	r3, [r7, #4]
 584 01dc 03F01F03 		and	r3, r3, #31
 585 01e0 7B60     		str	r3, [r7, #4]
 442:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 443:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 444:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Clear the useburst bit for this channel if set in ui32Config.
 445:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 446:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_USEBURST)
 586              		.loc 1 446 0
 587 01e2 3B68     		ldr	r3, [r7]
 588 01e4 03F00103 		and	r3, r3, #1
 589 01e8 002B     		cmp	r3, #0
 590 01ea 05D0     		beq	.L47
 447:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 448:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         HWREG(UDMA_USEBURSTCLR) = 1 << ui32ChannelNum;
 591              		.loc 1 448 0
 592 01ec 154A     		ldr	r2, .L52
 593 01ee 0121     		movs	r1, #1
 594 01f0 7B68     		ldr	r3, [r7, #4]
 595 01f2 01FA03F3 		lsl	r3, r1, r3
 596 01f6 1360     		str	r3, [r2]
 597              	.L47:
 449:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 450:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 451:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 452:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Clear the alternate control select bit for this channel, if set in
 453:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // ui32Config.
 454:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 455:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_ALTSELECT)
 598              		.loc 1 455 0
 599 01f8 3B68     		ldr	r3, [r7]
 600 01fa 03F00203 		and	r3, r3, #2
 601 01fe 002B     		cmp	r3, #0
 602 0200 05D0     		beq	.L48
 456:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 457:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         HWREG(UDMA_ALTCLR) = 1 << ui32ChannelNum;
 603              		.loc 1 457 0
 604 0202 114A     		ldr	r2, .L52+4
 605 0204 0121     		movs	r1, #1
 606 0206 7B68     		ldr	r3, [r7, #4]
 607 0208 01FA03F3 		lsl	r3, r1, r3
 608 020c 1360     		str	r3, [r2]
 609              	.L48:
 458:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 459:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 460:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 461:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Clear the high priority bit for this channel, if set in ui32Config.
 462:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 463:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_HIGH_PRIORITY)
 610              		.loc 1 463 0
 611 020e 3B68     		ldr	r3, [r7]
 612 0210 03F00403 		and	r3, r3, #4
 613 0214 002B     		cmp	r3, #0
 614 0216 05D0     		beq	.L49
 464:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 465:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         HWREG(UDMA_PRIOCLR) = 1 << ui32ChannelNum;
 615              		.loc 1 465 0
 616 0218 0C4A     		ldr	r2, .L52+8
 617 021a 0121     		movs	r1, #1
 618 021c 7B68     		ldr	r3, [r7, #4]
 619 021e 01FA03F3 		lsl	r3, r1, r3
 620 0222 1360     		str	r3, [r2]
 621              	.L49:
 466:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 467:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 468:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 469:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Clear the request mask bit for this channel, if set in ui32Config.
 470:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 471:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32Attr & UDMA_ATTR_REQMASK)
 622              		.loc 1 471 0
 623 0224 3B68     		ldr	r3, [r7]
 624 0226 03F00803 		and	r3, r3, #8
 625 022a 002B     		cmp	r3, #0
 626 022c 05D0     		beq	.L51
 472:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 473:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         HWREG(UDMA_REQMASKCLR) = 1 << ui32ChannelNum;
 627              		.loc 1 473 0
 628 022e 084A     		ldr	r2, .L52+12
 629 0230 0121     		movs	r1, #1
 630 0232 7B68     		ldr	r3, [r7, #4]
 631 0234 01FA03F3 		lsl	r3, r1, r3
 632 0238 1360     		str	r3, [r2]
 633              	.L51:
 474:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 475:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 634              		.loc 1 475 0
 635 023a 00BF     		nop
 636 023c 0C37     		adds	r7, r7, #12
 637              		.cfi_def_cfa_offset 4
 638 023e BD46     		mov	sp, r7
 639              		.cfi_def_cfa_register 13
 640              		@ sp needed
 641 0240 80BC     		pop	{r7}
 642              		.cfi_restore 7
 643              		.cfi_def_cfa_offset 0
 644 0242 7047     		bx	lr
 645              	.L53:
 646              		.align	2
 647              	.L52:
 648 0244 1CF00F40 		.word	1074786332
 649 0248 34F00F40 		.word	1074786356
 650 024c 3CF00F40 		.word	1074786364
 651 0250 24F00F40 		.word	1074786340
 652              		.cfi_endproc
 653              	.LFE12:
 655              		.align	2
 656              		.global	uDMAChannelAttributeGet
 657              		.thumb
 658              		.thumb_func
 660              	uDMAChannelAttributeGet:
 661              	.LFB13:
 476:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 477:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 478:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 479:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Gets the enabled attributes of a uDMA channel
 480:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 481:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelNum is the channel to configure.
 482:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 483:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function returns a combination of flags representing the attributes of
 484:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! the uDMA channel.
 485:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 486:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return Returns the logical OR of the attributes of the uDMA channel, which
 487:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! can be any of the following:
 488:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only a burst
 489:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   mode.
 490:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
 491:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   for this channel.
 492:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
 493:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
 494:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   peripheral for this channel.
 495:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 496:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 497:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uint32_t
 498:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelAttributeGet(uint32_t ui32ChannelNum)
 499:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 662              		.loc 1 499 0
 663              		.cfi_startproc
 664              		@ args = 0, pretend = 0, frame = 16
 665              		@ frame_needed = 1, uses_anonymous_args = 0
 666              		@ link register save eliminated.
 667 0254 80B4     		push	{r7}
 668              		.cfi_def_cfa_offset 4
 669              		.cfi_offset 7, -4
 670 0256 85B0     		sub	sp, sp, #20
 671              		.cfi_def_cfa_offset 24
 672 0258 00AF     		add	r7, sp, #0
 673              		.cfi_def_cfa_register 7
 674 025a 7860     		str	r0, [r7, #4]
 500:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     uint32_t ui32Attr = 0;
 675              		.loc 1 500 0
 676 025c 0023     		movs	r3, #0
 677 025e FB60     		str	r3, [r7, #12]
 501:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 502:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 503:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
 504:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 505:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 506:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 507:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 508:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 509:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 510:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // from this parameter.
 511:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 512:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32ChannelNum &= 0x1f;
 678              		.loc 1 512 0
 679 0260 7B68     		ldr	r3, [r7, #4]
 680 0262 03F01F03 		and	r3, r3, #31
 681 0266 7B60     		str	r3, [r7, #4]
 513:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 514:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 515:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check to see if useburst bit is set for this channel.
 516:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 517:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(HWREG(UDMA_USEBURSTSET) & (1 << ui32ChannelNum))
 682              		.loc 1 517 0
 683 0268 1C4B     		ldr	r3, .L60
 684 026a 1B68     		ldr	r3, [r3]
 685 026c 0121     		movs	r1, #1
 686 026e 7A68     		ldr	r2, [r7, #4]
 687 0270 01FA02F2 		lsl	r2, r1, r2
 688 0274 1340     		ands	r3, r3, r2
 689 0276 002B     		cmp	r3, #0
 690 0278 03D0     		beq	.L55
 518:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 519:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         ui32Attr |= UDMA_ATTR_USEBURST;
 691              		.loc 1 519 0
 692 027a FB68     		ldr	r3, [r7, #12]
 693 027c 43F00103 		orr	r3, r3, #1
 694 0280 FB60     		str	r3, [r7, #12]
 695              	.L55:
 520:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 521:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 522:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 523:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check to see if the alternate control bit is set for this channel.
 524:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 525:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(HWREG(UDMA_ALTSET) & (1 << ui32ChannelNum))
 696              		.loc 1 525 0
 697 0282 174B     		ldr	r3, .L60+4
 698 0284 1B68     		ldr	r3, [r3]
 699 0286 0121     		movs	r1, #1
 700 0288 7A68     		ldr	r2, [r7, #4]
 701 028a 01FA02F2 		lsl	r2, r1, r2
 702 028e 1340     		ands	r3, r3, r2
 703 0290 002B     		cmp	r3, #0
 704 0292 03D0     		beq	.L56
 526:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 527:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         ui32Attr |= UDMA_ATTR_ALTSELECT;
 705              		.loc 1 527 0
 706 0294 FB68     		ldr	r3, [r7, #12]
 707 0296 43F00203 		orr	r3, r3, #2
 708 029a FB60     		str	r3, [r7, #12]
 709              	.L56:
 528:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 529:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 530:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 531:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check to see if the high priority bit is set for this channel.
 532:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 533:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(HWREG(UDMA_PRIOSET) & (1 << ui32ChannelNum))
 710              		.loc 1 533 0
 711 029c 114B     		ldr	r3, .L60+8
 712 029e 1B68     		ldr	r3, [r3]
 713 02a0 0121     		movs	r1, #1
 714 02a2 7A68     		ldr	r2, [r7, #4]
 715 02a4 01FA02F2 		lsl	r2, r1, r2
 716 02a8 1340     		ands	r3, r3, r2
 717 02aa 002B     		cmp	r3, #0
 718 02ac 03D0     		beq	.L57
 534:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 535:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         ui32Attr |= UDMA_ATTR_HIGH_PRIORITY;
 719              		.loc 1 535 0
 720 02ae FB68     		ldr	r3, [r7, #12]
 721 02b0 43F00403 		orr	r3, r3, #4
 722 02b4 FB60     		str	r3, [r7, #12]
 723              	.L57:
 536:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 537:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 538:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 539:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check to see if the request mask bit is set for this channel.
 540:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 541:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(HWREG(UDMA_REQMASKSET) & (1 << ui32ChannelNum))
 724              		.loc 1 541 0
 725 02b6 0C4B     		ldr	r3, .L60+12
 726 02b8 1B68     		ldr	r3, [r3]
 727 02ba 0121     		movs	r1, #1
 728 02bc 7A68     		ldr	r2, [r7, #4]
 729 02be 01FA02F2 		lsl	r2, r1, r2
 730 02c2 1340     		ands	r3, r3, r2
 731 02c4 002B     		cmp	r3, #0
 732 02c6 03D0     		beq	.L58
 542:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 543:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         ui32Attr |= UDMA_ATTR_REQMASK;
 733              		.loc 1 543 0
 734 02c8 FB68     		ldr	r3, [r7, #12]
 735 02ca 43F00803 		orr	r3, r3, #8
 736 02ce FB60     		str	r3, [r7, #12]
 737              	.L58:
 544:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 545:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 546:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 547:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Return the configuration flags.
 548:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 549:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     return(ui32Attr);
 738              		.loc 1 549 0
 739 02d0 FB68     		ldr	r3, [r7, #12]
 550:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 740              		.loc 1 550 0
 741 02d2 1846     		mov	r0, r3
 742 02d4 1437     		adds	r7, r7, #20
 743              		.cfi_def_cfa_offset 4
 744 02d6 BD46     		mov	sp, r7
 745              		.cfi_def_cfa_register 13
 746              		@ sp needed
 747 02d8 80BC     		pop	{r7}
 748              		.cfi_restore 7
 749              		.cfi_def_cfa_offset 0
 750 02da 7047     		bx	lr
 751              	.L61:
 752              		.align	2
 753              	.L60:
 754 02dc 18F00F40 		.word	1074786328
 755 02e0 30F00F40 		.word	1074786352
 756 02e4 38F00F40 		.word	1074786360
 757 02e8 20F00F40 		.word	1074786336
 758              		.cfi_endproc
 759              	.LFE13:
 761              		.align	2
 762              		.global	uDMAChannelControlSet
 763              		.thumb
 764              		.thumb_func
 766              	uDMAChannelControlSet:
 767              	.LFB14:
 551:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 552:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 553:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 554:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Sets the control parameters for a uDMA channel control structure
 555:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 556:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 557:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! with \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 558:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32Control is logical OR of several control values to set the control
 559:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! parameters for the channel.
 560:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 561:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function is used to set control parameters for a uDMA transfer.  These
 562:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! are typically parameters that are not changed often.
 563:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 564:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The \e ui32ChannelStructIndex parameter should be the logical OR of the
 565:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! channel number with one of \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT to
 566:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! choose whether the primary or alternate data structure is used.
 567:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 568:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The \e ui32Control parameter is the logical OR of five values: the data size,
 569:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! the source address increment, the destination address increment, the
 570:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! arbitration size, and the use burst flag.  The choices available for each
 571:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! of these values is described below.
 572:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 573:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Choose the data size from one of \b UDMA_SIZE_8, \b UDMA_SIZE_16, or
 574:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \b UDMA_SIZE_32 to select a data size of 8, 16, or 32 bits.
 575:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 576:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Choose the source address increment from one of \b UDMA_SRC_INC_8,
 577:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \b UDMA_SRC_INC_16, \b UDMA_SRC_INC_32, or \b UDMA_SRC_INC_NONE to select
 578:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! an address increment of 8-bit bytes, 16-bit halfwords, 32-bit words, or
 579:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! to select non-incrementing.
 580:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 581:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Choose the destination address increment from one of \b UDMA_DST_INC_8,
 582:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \b UDMA_DST_INC_16, \b UDMA_DST_INC_32, or \b UDMA_DST_INC_NONE to select
 583:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! an address increment of 8-bit bytes, 16-bit halfwords, 32-bit words, or
 584:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! to select non-incrementing.
 585:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 586:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The arbitration size determines how many items are transferred before
 587:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! the uDMA controller re-arbitrates for the bus.  Choose the arbitration size
 588:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! from one of \b UDMA_ARB_1, \b UDMA_ARB_2, \b UDMA_ARB_4, \b UDMA_ARB_8,
 589:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! through \b UDMA_ARB_1024 to select the arbitration size from 1 to 1024
 590:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! items, in powers of 2.
 591:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 592:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The value \b UDMA_NEXT_USEBURST is used to force the channel to only
 593:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! respond to burst requests at the tail end of a scatter-gather transfer.
 594:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 595:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \note The address increment cannot be smaller than the data size.
 596:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 597:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
 598:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 599:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 600:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
 601:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelControlSet(uint32_t ui32ChannelStructIndex,
 602:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                       uint32_t ui32Control)
 603:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 768              		.loc 1 603 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 16
 771              		@ frame_needed = 1, uses_anonymous_args = 0
 772              		@ link register save eliminated.
 773 02ec 80B4     		push	{r7}
 774              		.cfi_def_cfa_offset 4
 775              		.cfi_offset 7, -4
 776 02ee 85B0     		sub	sp, sp, #20
 777              		.cfi_def_cfa_offset 24
 778 02f0 00AF     		add	r7, sp, #0
 779              		.cfi_def_cfa_register 7
 780 02f2 7860     		str	r0, [r7, #4]
 781 02f4 3960     		str	r1, [r7]
 604:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     tDMAControlTable *pCtl;
 605:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 606:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 607:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
 608:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 609:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
 610:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 611:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 612:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 613:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 614:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
 615:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // index from this parameter.
 616:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 617:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 782              		.loc 1 617 0
 783 02f6 7B68     		ldr	r3, [r7, #4]
 784 02f8 03F03F03 		and	r3, r3, #63
 785 02fc 7B60     		str	r3, [r7, #4]
 618:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 619:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 620:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get the base address of the control table.
 621:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 622:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pCtl = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 786              		.loc 1 622 0
 787 02fe 0B4B     		ldr	r3, .L63
 788 0300 1B68     		ldr	r3, [r3]
 789 0302 FB60     		str	r3, [r7, #12]
 623:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 624:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 625:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get the current control word value and mask off the fields to be
 626:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // changed, then OR in the new settings.
 627:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 628:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pCtl[ui32ChannelStructIndex].ui32Control =
 790              		.loc 1 628 0
 791 0304 7B68     		ldr	r3, [r7, #4]
 792 0306 1B01     		lsls	r3, r3, #4
 793 0308 FA68     		ldr	r2, [r7, #12]
 794 030a 1A44     		add	r2, r2, r3
 629:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         ((pCtl[ui32ChannelStructIndex].ui32Control &
 795              		.loc 1 629 0
 796 030c 7B68     		ldr	r3, [r7, #4]
 797 030e 1B01     		lsls	r3, r3, #4
 798 0310 F968     		ldr	r1, [r7, #12]
 799 0312 0B44     		add	r3, r3, r1
 800 0314 9968     		ldr	r1, [r3, #8]
 801 0316 064B     		ldr	r3, .L63+4
 802 0318 0B40     		ands	r3, r3, r1
 630:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****           ~(UDMACHCTL_CHCTL_DSTINC_M |
 631:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             UDMACHCTL_CHCTL_DSTSIZE_M |
 632:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             UDMACHCTL_CHCTL_SRCINC_M |
 633:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             UDMACHCTL_CHCTL_SRCSIZE_M |
 634:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             UDMACHCTL_CHCTL_ARBSIZE_M |
 635:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             UDMACHCTL_CHCTL_NXTUSEBURST)) |
 803              		.loc 1 635 0
 804 031a 3968     		ldr	r1, [r7]
 805 031c 0B43     		orrs	r3, r3, r1
 628:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         ((pCtl[ui32ChannelStructIndex].ui32Control &
 806              		.loc 1 628 0
 807 031e 9360     		str	r3, [r2, #8]
 636:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****          ui32Control);
 637:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 808              		.loc 1 637 0
 809 0320 00BF     		nop
 810 0322 1437     		adds	r7, r7, #20
 811              		.cfi_def_cfa_offset 4
 812 0324 BD46     		mov	sp, r7
 813              		.cfi_def_cfa_register 13
 814              		@ sp needed
 815 0326 80BC     		pop	{r7}
 816              		.cfi_restore 7
 817              		.cfi_def_cfa_offset 0
 818 0328 7047     		bx	lr
 819              	.L64:
 820 032a 00BF     		.align	2
 821              	.L63:
 822 032c 08F00F40 		.word	1074786312
 823 0330 F73FFC00 		.word	16531447
 824              		.cfi_endproc
 825              	.LFE14:
 827              		.align	2
 828              		.global	uDMAChannelTransferSet
 829              		.thumb
 830              		.thumb_func
 832              	uDMAChannelTransferSet:
 833              	.LFB15:
 638:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 639:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 640:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 641:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Sets the transfer parameters for a uDMA channel control structure
 642:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 643:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 644:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 645:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32Mode is the type of uDMA transfer.
 646:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param pvSrcAddr is the source address for the transfer.
 647:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param pvDstAddr is the destination address for the transfer.
 648:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32TransferSize is the number of data items to transfer.
 649:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 650:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function is used to set the parameters for a uDMA transfer.  These are
 651:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! typically parameters that are changed often.  The function
 652:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! uDMAChannelControlSet() MUST be called at least once for this channel prior
 653:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! to calling this function.
 654:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 655:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The \e ui32ChannelStructIndex parameter should be the logical OR of the
 656:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! channel number with one of \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT to
 657:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! choose whether the primary or alternate data structure is used.
 658:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 659:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The \e ui32Mode parameter should be one of the following values:
 660:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 661:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_MODE_STOP stops the uDMA transfer.  The controller sets the mode
 662:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   to this value at the end of a transfer.
 663:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_MODE_BASIC to perform a basic transfer based on request.
 664:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_MODE_AUTO to perform a transfer that will always complete once
 665:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   started even if request is removed.
 666:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_MODE_PINGPONG to set up a transfer that switches between the
 667:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   primary and alternate control structures for the channel.  This allows
 668:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   use of ping-pong buffering for uDMA transfers.
 669:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_MODE_MEM_SCATTER_GATHER to set up a memory scatter-gather
 670:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   transfer.
 671:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_MODE_PER_SCATTER_GATHER to set up a peripheral scatter-gather
 672:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   transfer.
 673:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 674:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The \e pvSrcAddr and \e pvDstAddr parameters are pointers to the first
 675:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! location of the data to be transferred.  These addresses should be aligned
 676:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! according to the item size.  The compiler will take care of this if the
 677:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! pointers are pointing to storage of the appropriate data type.
 678:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 679:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The \e ui32TransferSize parameter is the number of data items, not the number
 680:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! of bytes.
 681:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 682:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The two scatter/gather modes, memory and peripheral, are actually different
 683:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! depending on whether the primary or alternate control structure is
 684:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! selected.  This function will look for the \b UDMA_PRI_SELECT and
 685:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \b UDMA_ALT_SELECT flag along with the channel number and will set the
 686:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! scatter/gather mode as appropriate for the primary or alternate control
 687:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! structure.
 688:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 689:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The channel must also be enabled using uDMAChannelEnable() after calling
 690:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! this function.  The transfer will not begin until the channel has been set
 691:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! up and enabled.  Note that the channel is automatically disabled after the
 692:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! transfer is completed, meaning that uDMAChannelEnable() must be called
 693:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! again after setting up the next transfer.
 694:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 695:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \note Great care must be taken to not modify a channel control structure
 696:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! that is in use or else the results will be unpredictable, including the
 697:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! possibility of undesired data transfers to or from memory or peripherals.
 698:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! For BASIC and AUTO modes, it is safe to make changes when the channel is
 699:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! disabled, or the uDMAChannelModeGet() returns \b UDMA_MODE_STOP.  For
 700:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! PINGPONG or one of the SCATTER_GATHER modes, it is safe to modify the
 701:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! primary or alternate control structure only when the other is being used.
 702:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The uDMAChannelModeGet() function will return \b UDMA_MODE_STOP when a
 703:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! channel control structure is inactive and safe to modify.
 704:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 705:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
 706:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 707:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 708:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
 709:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelTransferSet(uint32_t ui32ChannelStructIndex,
 710:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                        uint32_t ui32Mode, void *pvSrcAddr, void *pvDstAddr,
 711:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                        uint32_t ui32TransferSize)
 712:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 834              		.loc 1 712 0
 835              		.cfi_startproc
 836              		@ args = 4, pretend = 0, frame = 32
 837              		@ frame_needed = 1, uses_anonymous_args = 0
 838              		@ link register save eliminated.
 839 0334 80B4     		push	{r7}
 840              		.cfi_def_cfa_offset 4
 841              		.cfi_offset 7, -4
 842 0336 89B0     		sub	sp, sp, #36
 843              		.cfi_def_cfa_offset 40
 844 0338 00AF     		add	r7, sp, #0
 845              		.cfi_def_cfa_register 7
 846 033a F860     		str	r0, [r7, #12]
 847 033c B960     		str	r1, [r7, #8]
 848 033e 7A60     		str	r2, [r7, #4]
 849 0340 3B60     		str	r3, [r7]
 713:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     tDMAControlTable *pControlTable;
 714:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     uint32_t ui32Control;
 715:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     uint32_t ui32Inc;
 716:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     uint32_t ui32BufferBytes;
 717:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 718:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 719:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
 720:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 721:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
 722:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 723:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT(ui32Mode <= UDMA_MODE_PER_SCATTER_GATHER);
 724:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((uint32_t)pvSrcAddr >= 0x20000000);
 725:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((uint32_t)pvDstAddr >= 0x20000000);
 726:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32TransferSize != 0) && (ui32TransferSize <= 1024));
 727:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 728:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 729:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 730:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
 731:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // index from this parameter.
 732:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 733:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 850              		.loc 1 733 0
 851 0342 FB68     		ldr	r3, [r7, #12]
 852 0344 03F03F03 		and	r3, r3, #63
 853 0348 FB60     		str	r3, [r7, #12]
 734:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 735:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 736:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get the base address of the control table.
 737:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 738:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 854              		.loc 1 738 0
 855 034a 3A4B     		ldr	r3, .L72
 856 034c 1B68     		ldr	r3, [r3]
 857 034e FB61     		str	r3, [r7, #28]
 739:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 740:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 741:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get the current control word value and mask off the mode and size
 742:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // fields.
 743:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 744:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32Control = (pControlTable[ui32ChannelStructIndex].ui32Control &
 858              		.loc 1 744 0
 859 0350 FB68     		ldr	r3, [r7, #12]
 860 0352 1B01     		lsls	r3, r3, #4
 861 0354 FA69     		ldr	r2, [r7, #28]
 862 0356 1344     		add	r3, r3, r2
 863 0358 9B68     		ldr	r3, [r3, #8]
 864 035a 23F47F53 		bic	r3, r3, #16320
 865 035e 23F03703 		bic	r3, r3, #55
 866 0362 BB61     		str	r3, [r7, #24]
 745:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                    ~(UDMACHCTL_CHCTL_XFERSIZE_M | UDMACHCTL_CHCTL_XFERMODE_M));
 746:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 747:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 748:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Adjust the mode if the alt control structure is selected.
 749:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 750:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32ChannelStructIndex & UDMA_ALT_SELECT)
 867              		.loc 1 750 0
 868 0364 FB68     		ldr	r3, [r7, #12]
 869 0366 03F02003 		and	r3, r3, #32
 870 036a 002B     		cmp	r3, #0
 871 036c 09D0     		beq	.L66
 751:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 752:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         if((ui32Mode == UDMA_MODE_MEM_SCATTER_GATHER) ||
 872              		.loc 1 752 0
 873 036e BB68     		ldr	r3, [r7, #8]
 874 0370 042B     		cmp	r3, #4
 875 0372 02D0     		beq	.L67
 876              		.loc 1 752 0 is_stmt 0 discriminator 1
 877 0374 BB68     		ldr	r3, [r7, #8]
 878 0376 062B     		cmp	r3, #6
 879 0378 03D1     		bne	.L66
 880              	.L67:
 753:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                 (ui32Mode == UDMA_MODE_PER_SCATTER_GATHER))
 754:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         {
 755:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             ui32Mode |= UDMA_MODE_ALT_SELECT;
 881              		.loc 1 755 0 is_stmt 1
 882 037a BB68     		ldr	r3, [r7, #8]
 883 037c 43F00103 		orr	r3, r3, #1
 884 0380 BB60     		str	r3, [r7, #8]
 885              	.L66:
 756:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         }
 757:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 758:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 759:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 760:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Set the transfer size and mode in the control word (but don't write the
 761:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // control word yet as it could kick off a transfer).
 762:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 763:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32Control |= ui32Mode | ((ui32TransferSize - 1) << 4);
 886              		.loc 1 763 0
 887 0382 BB6A     		ldr	r3, [r7, #40]
 888 0384 013B     		subs	r3, r3, #1
 889 0386 1A01     		lsls	r2, r3, #4
 890 0388 BB68     		ldr	r3, [r7, #8]
 891 038a 1343     		orrs	r3, r3, r2
 892 038c BA69     		ldr	r2, [r7, #24]
 893 038e 1343     		orrs	r3, r3, r2
 894 0390 BB61     		str	r3, [r7, #24]
 764:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 765:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 766:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get the address increment value for the source, from the control word.
 767:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 768:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32Inc = (ui32Control & UDMACHCTL_CHCTL_SRCINC_M);
 895              		.loc 1 768 0
 896 0392 BB69     		ldr	r3, [r7, #24]
 897 0394 03F04063 		and	r3, r3, #201326592
 898 0398 7B61     		str	r3, [r7, #20]
 769:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 770:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 771:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Compute the ending source address of the transfer.  If the source
 772:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // increment is set to none, then the ending address is the same as the
 773:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // beginning.
 774:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 775:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32Inc != UDMA_SRC_INC_NONE)
 899              		.loc 1 775 0
 900 039a 7B69     		ldr	r3, [r7, #20]
 901 039c B3F1406F 		cmp	r3, #201326592
 902 03a0 0CD0     		beq	.L68
 776:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 777:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         ui32Inc = ui32Inc >> 26;
 903              		.loc 1 777 0
 904 03a2 7B69     		ldr	r3, [r7, #20]
 905 03a4 9B0E     		lsrs	r3, r3, #26
 906 03a6 7B61     		str	r3, [r7, #20]
 778:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         ui32BufferBytes = ui32TransferSize << ui32Inc;
 907              		.loc 1 778 0
 908 03a8 BA6A     		ldr	r2, [r7, #40]
 909 03aa 7B69     		ldr	r3, [r7, #20]
 910 03ac 02FA03F3 		lsl	r3, r2, r3
 911 03b0 3B61     		str	r3, [r7, #16]
 779:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         pvSrcAddr = (void *)((uint32_t)pvSrcAddr + ui32BufferBytes - 1);
 912              		.loc 1 779 0
 913 03b2 7A68     		ldr	r2, [r7, #4]
 914 03b4 3B69     		ldr	r3, [r7, #16]
 915 03b6 1344     		add	r3, r3, r2
 916 03b8 013B     		subs	r3, r3, #1
 917 03ba 7B60     		str	r3, [r7, #4]
 918              	.L68:
 780:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 781:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 782:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 783:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Load the source ending address into the control block.
 784:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 785:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pControlTable[ui32ChannelStructIndex].pvSrcEndAddr = pvSrcAddr;
 919              		.loc 1 785 0
 920 03bc FB68     		ldr	r3, [r7, #12]
 921 03be 1B01     		lsls	r3, r3, #4
 922 03c0 FA69     		ldr	r2, [r7, #28]
 923 03c2 1344     		add	r3, r3, r2
 924 03c4 7A68     		ldr	r2, [r7, #4]
 925 03c6 1A60     		str	r2, [r3]
 786:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 787:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 788:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get the address increment value for the destination, from the control
 789:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // word.
 790:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 791:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32Inc = ui32Control & UDMACHCTL_CHCTL_DSTINC_M;
 926              		.loc 1 791 0
 927 03c8 BB69     		ldr	r3, [r7, #24]
 928 03ca 03F04043 		and	r3, r3, #-1073741824
 929 03ce 7B61     		str	r3, [r7, #20]
 792:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 793:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 794:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Compute the ending destination address of the transfer.  If the
 795:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // destination increment is set to none, then the ending address is the
 796:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // same as the beginning.
 797:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 798:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32Inc != UDMA_DST_INC_NONE)
 930              		.loc 1 798 0
 931 03d0 7B69     		ldr	r3, [r7, #20]
 932 03d2 B3F1404F 		cmp	r3, #-1073741824
 933 03d6 1BD0     		beq	.L69
 799:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 800:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         //
 801:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         // There is a special case if this is setting up a scatter-gather
 802:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         // transfer.  The destination pointer needs to point to the end of
 803:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         // the alternate structure for this channel instead of calculating
 804:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         // the end of the buffer in the normal way.
 805:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         //
 806:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         if((ui32Mode == UDMA_MODE_MEM_SCATTER_GATHER) ||
 934              		.loc 1 806 0
 935 03d8 BB68     		ldr	r3, [r7, #8]
 936 03da 042B     		cmp	r3, #4
 937 03dc 02D0     		beq	.L70
 938              		.loc 1 806 0 is_stmt 0 discriminator 1
 939 03de BB68     		ldr	r3, [r7, #8]
 940 03e0 062B     		cmp	r3, #6
 941 03e2 08D1     		bne	.L71
 942              	.L70:
 807:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                 (ui32Mode == UDMA_MODE_PER_SCATTER_GATHER))
 808:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         {
 809:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             pvDstAddr =
 810:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                 (void *)&pControlTable[ui32ChannelStructIndex |
 943              		.loc 1 810 0 is_stmt 1
 944 03e4 FB68     		ldr	r3, [r7, #12]
 945 03e6 43F02003 		orr	r3, r3, #32
 946 03ea 1B01     		lsls	r3, r3, #4
 947 03ec FA69     		ldr	r2, [r7, #28]
 948 03ee 1344     		add	r3, r3, r2
 809:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                 (void *)&pControlTable[ui32ChannelStructIndex |
 949              		.loc 1 809 0
 950 03f0 0C33     		adds	r3, r3, #12
 951 03f2 3B60     		str	r3, [r7]
 952 03f4 0CE0     		b	.L69
 953              	.L71:
 811:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                                        UDMA_ALT_SELECT].ui32Spare;
 812:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         }
 813:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         //
 814:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         // Not a scatter-gather transfer, calculate end pointer normally.
 815:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         //
 816:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         else
 817:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         {
 818:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             ui32Inc = ui32Inc >> 30;
 954              		.loc 1 818 0
 955 03f6 7B69     		ldr	r3, [r7, #20]
 956 03f8 9B0F     		lsrs	r3, r3, #30
 957 03fa 7B61     		str	r3, [r7, #20]
 819:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             ui32BufferBytes = ui32TransferSize << ui32Inc;
 958              		.loc 1 819 0
 959 03fc BA6A     		ldr	r2, [r7, #40]
 960 03fe 7B69     		ldr	r3, [r7, #20]
 961 0400 02FA03F3 		lsl	r3, r2, r3
 962 0404 3B61     		str	r3, [r7, #16]
 820:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             pvDstAddr = (void *)((uint32_t)pvDstAddr + ui32BufferBytes - 1);
 963              		.loc 1 820 0
 964 0406 3A68     		ldr	r2, [r7]
 965 0408 3B69     		ldr	r3, [r7, #16]
 966 040a 1344     		add	r3, r3, r2
 967 040c 013B     		subs	r3, r3, #1
 968 040e 3B60     		str	r3, [r7]
 969              	.L69:
 821:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         }
 822:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 823:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 824:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 825:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Load the destination ending address into the control block.
 826:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 827:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pControlTable[ui32ChannelStructIndex].pvDstEndAddr = pvDstAddr;
 970              		.loc 1 827 0
 971 0410 FB68     		ldr	r3, [r7, #12]
 972 0412 1B01     		lsls	r3, r3, #4
 973 0414 FA69     		ldr	r2, [r7, #28]
 974 0416 1344     		add	r3, r3, r2
 975 0418 3A68     		ldr	r2, [r7]
 976 041a 5A60     		str	r2, [r3, #4]
 828:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 829:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 830:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Write the new control word value.
 831:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 832:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pControlTable[ui32ChannelStructIndex].ui32Control = ui32Control;
 977              		.loc 1 832 0
 978 041c FB68     		ldr	r3, [r7, #12]
 979 041e 1B01     		lsls	r3, r3, #4
 980 0420 FA69     		ldr	r2, [r7, #28]
 981 0422 1344     		add	r3, r3, r2
 982 0424 BA69     		ldr	r2, [r7, #24]
 983 0426 9A60     		str	r2, [r3, #8]
 833:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 984              		.loc 1 833 0
 985 0428 00BF     		nop
 986 042a 2437     		adds	r7, r7, #36
 987              		.cfi_def_cfa_offset 4
 988 042c BD46     		mov	sp, r7
 989              		.cfi_def_cfa_register 13
 990              		@ sp needed
 991 042e 80BC     		pop	{r7}
 992              		.cfi_restore 7
 993              		.cfi_def_cfa_offset 0
 994 0430 7047     		bx	lr
 995              	.L73:
 996 0432 00BF     		.align	2
 997              	.L72:
 998 0434 08F00F40 		.word	1074786312
 999              		.cfi_endproc
 1000              	.LFE15:
 1002              		.align	2
 1003              		.global	uDMAChannelScatterGatherSet
 1004              		.thumb
 1005              		.thumb_func
 1007              	uDMAChannelScatterGatherSet:
 1008              	.LFB16:
 834:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 835:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 836:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 837:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Configures a uDMA channel for scatter-gather mode
 838:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 839:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelNum is the uDMA channel number.
 840:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32TaskCount is the number of scatter-gather tasks to execute.
 841:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param pvTaskList is a pointer to the beginning of the scatter-gather
 842:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! task list.
 843:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32IsPeriphSG is a flag to indicate it is a peripheral scatter-gather
 844:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! transfer (else it will be memory scatter-gather transfer)
 845:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 846:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function is used to configure a channel for scatter-gather mode.
 847:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The caller must have already set up a task list, and pass a pointer to
 848:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! the start of the task list as the \e pvTaskList parameter.  The
 849:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \e ui32TaskCount parameter is the count of tasks in the task list, not the
 850:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! size of the task list.  The flag \e bIsPeriphSG should be used to indicate
 851:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! if the scatter-gather should be configured for a peripheral or memory
 852:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! scatter-gather operation.
 853:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 854:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \sa uDMATaskStructEntry
 855:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 856:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
 857:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 858:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 859:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
 860:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelScatterGatherSet(uint32_t ui32ChannelNum,
 861:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                             uint32_t ui32TaskCount, void *pvTaskList,
 862:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                             uint32_t ui32IsPeriphSG)
 863:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 1009              		.loc 1 863 0
 1010              		.cfi_startproc
 1011              		@ args = 0, pretend = 0, frame = 24
 1012              		@ frame_needed = 1, uses_anonymous_args = 0
 1013              		@ link register save eliminated.
 1014 0438 80B4     		push	{r7}
 1015              		.cfi_def_cfa_offset 4
 1016              		.cfi_offset 7, -4
 1017 043a 87B0     		sub	sp, sp, #28
 1018              		.cfi_def_cfa_offset 32
 1019 043c 00AF     		add	r7, sp, #0
 1020              		.cfi_def_cfa_register 7
 1021 043e F860     		str	r0, [r7, #12]
 1022 0440 B960     		str	r1, [r7, #8]
 1023 0442 7A60     		str	r2, [r7, #4]
 1024 0444 3B60     		str	r3, [r7]
 864:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     tDMAControlTable *pControlTable;
 865:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     tDMAControlTable *pTaskTable;
 866:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 867:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 868:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the parameters
 869:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 870:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 871:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 872:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT(pvTaskList != 0);
 873:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT(ui32TaskCount <= 1024);
 874:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT(ui32TaskCount != 0);
 875:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 876:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 877:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 878:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 879:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // from this parameter.
 880:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 881:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32ChannelNum &= 0x1f;
 1025              		.loc 1 881 0
 1026 0446 FB68     		ldr	r3, [r7, #12]
 1027 0448 03F01F03 		and	r3, r3, #31
 1028 044c FB60     		str	r3, [r7, #12]
 882:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 883:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 884:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get the base address of the control table.
 885:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 886:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 1029              		.loc 1 886 0
 1030 044e 1B4B     		ldr	r3, .L77
 1031 0450 1B68     		ldr	r3, [r3]
 1032 0452 7B61     		str	r3, [r7, #20]
 887:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 888:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 889:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get a handy pointer to the task list
 890:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 891:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pTaskTable = (tDMAControlTable *)pvTaskList;
 1033              		.loc 1 891 0
 1034 0454 7B68     		ldr	r3, [r7, #4]
 1035 0456 3B61     		str	r3, [r7, #16]
 892:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 893:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 894:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Compute the ending address for the source pointer.  This will be the
 895:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // last element of the last task in the task table
 896:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 897:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pControlTable[ui32ChannelNum].pvSrcEndAddr =
 1036              		.loc 1 897 0
 1037 0458 FB68     		ldr	r3, [r7, #12]
 1038 045a 1B01     		lsls	r3, r3, #4
 1039 045c 7A69     		ldr	r2, [r7, #20]
 1040 045e 1A44     		add	r2, r2, r3
 898:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         &pTaskTable[ui32TaskCount - 1].ui32Spare;
 1041              		.loc 1 898 0
 1042 0460 BB68     		ldr	r3, [r7, #8]
 1043 0462 03F18053 		add	r3, r3, #268435456
 1044 0466 013B     		subs	r3, r3, #1
 1045 0468 1B01     		lsls	r3, r3, #4
 1046 046a 3969     		ldr	r1, [r7, #16]
 1047 046c 0B44     		add	r3, r3, r1
 1048 046e 0C33     		adds	r3, r3, #12
 897:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         &pTaskTable[ui32TaskCount - 1].ui32Spare;
 1049              		.loc 1 897 0
 1050 0470 1360     		str	r3, [r2]
 899:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 900:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 901:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Compute the ending address for the destination pointer.  This will be
 902:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // the end of the alternate structure for this channel.
 903:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 904:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pControlTable[ui32ChannelNum].pvDstEndAddr =
 1051              		.loc 1 904 0
 1052 0472 FB68     		ldr	r3, [r7, #12]
 1053 0474 1B01     		lsls	r3, r3, #4
 1054 0476 7A69     		ldr	r2, [r7, #20]
 1055 0478 1344     		add	r3, r3, r2
 905:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         &pControlTable[ui32ChannelNum | UDMA_ALT_SELECT].ui32Spare;
 1056              		.loc 1 905 0
 1057 047a FA68     		ldr	r2, [r7, #12]
 1058 047c 42F02002 		orr	r2, r2, #32
 1059 0480 1201     		lsls	r2, r2, #4
 1060 0482 7969     		ldr	r1, [r7, #20]
 1061 0484 0A44     		add	r2, r2, r1
 1062 0486 0C32     		adds	r2, r2, #12
 904:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         &pControlTable[ui32ChannelNum | UDMA_ALT_SELECT].ui32Spare;
 1063              		.loc 1 904 0
 1064 0488 5A60     		str	r2, [r3, #4]
 906:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 907:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 908:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Compute the control word.  Most configurable items are fixed for
 909:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // scatter-gather.  Item and increment sizes are all 32-bit and arb
 910:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // size must be 4.  The count is the number of items in the task list
 911:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // times 4 (4 words per task).
 912:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 913:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pControlTable[ui32ChannelNum].ui32Control =
 1065              		.loc 1 913 0
 1066 048a FB68     		ldr	r3, [r7, #12]
 1067 048c 1B01     		lsls	r3, r3, #4
 1068 048e 7A69     		ldr	r2, [r7, #20]
 1069 0490 1A44     		add	r2, r2, r3
 914:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         (UDMA_CHCTL_DSTINC_32 | UDMA_CHCTL_DSTSIZE_32 |
 915:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****          UDMA_CHCTL_SRCINC_32 | UDMA_CHCTL_SRCSIZE_32 |
 916:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****          UDMA_CHCTL_ARBSIZE_4 |
 917:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****          (((ui32TaskCount * 4) - 1) << UDMACHCTL_CHCTL_XFERSIZE_S) |
 1070              		.loc 1 917 0
 1071 0492 BB68     		ldr	r3, [r7, #8]
 1072 0494 9B00     		lsls	r3, r3, #2
 1073 0496 013B     		subs	r3, r3, #1
 1074 0498 1901     		lsls	r1, r3, #4
 1075 049a 3B68     		ldr	r3, [r7]
 1076 049c 002B     		cmp	r3, #0
 1077 049e 01D0     		beq	.L75
 1078              		.loc 1 917 0 is_stmt 0 discriminator 1
 1079 04a0 0623     		movs	r3, #6
 1080 04a2 00E0     		b	.L76
 1081              	.L75:
 1082              		.loc 1 917 0 discriminator 2
 1083 04a4 0423     		movs	r3, #4
 1084              	.L76:
 1085              		.loc 1 917 0 discriminator 4
 1086 04a6 0B43     		orrs	r3, r3, r1
 1087 04a8 43F02A43 		orr	r3, r3, #-1442840576
 1088 04ac 43F40043 		orr	r3, r3, #32768
 913:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         (UDMA_CHCTL_DSTINC_32 | UDMA_CHCTL_DSTSIZE_32 |
 1089              		.loc 1 913 0 is_stmt 1 discriminator 4
 1090 04b0 9360     		str	r3, [r2, #8]
 918:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****          (ui32IsPeriphSG ? UDMA_CHCTL_XFERMODE_PER_SG :
 919:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****           UDMA_CHCTL_XFERMODE_MEM_SG));
 920:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 1091              		.loc 1 920 0 discriminator 4
 1092 04b2 00BF     		nop
 1093 04b4 1C37     		adds	r7, r7, #28
 1094              		.cfi_def_cfa_offset 4
 1095 04b6 BD46     		mov	sp, r7
 1096              		.cfi_def_cfa_register 13
 1097              		@ sp needed
 1098 04b8 80BC     		pop	{r7}
 1099              		.cfi_restore 7
 1100              		.cfi_def_cfa_offset 0
 1101 04ba 7047     		bx	lr
 1102              	.L78:
 1103              		.align	2
 1104              	.L77:
 1105 04bc 08F00F40 		.word	1074786312
 1106              		.cfi_endproc
 1107              	.LFE16:
 1109              		.align	2
 1110              		.global	uDMAChannelSizeGet
 1111              		.thumb
 1112              		.thumb_func
 1114              	uDMAChannelSizeGet:
 1115              	.LFB17:
 921:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 922:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 923:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 924:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Gets the current transfer size for a uDMA channel control structure
 925:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 926:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 927:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 928:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 929:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function is used to get the uDMA transfer size for a channel.  The
 930:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! transfer size is the number of items to transfer, where the size of an item
 931:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! might be 8, 16, or 32 bits.  If a partial transfer has already occurred,
 932:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! then the number of remaining items will be returned.  If the transfer is
 933:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! complete, then 0 will be returned.
 934:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 935:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return Returns the number of items remaining to transfer.
 936:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 937:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 938:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uint32_t
 939:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelSizeGet(uint32_t ui32ChannelStructIndex)
 940:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 1116              		.loc 1 940 0
 1117              		.cfi_startproc
 1118              		@ args = 0, pretend = 0, frame = 16
 1119              		@ frame_needed = 1, uses_anonymous_args = 0
 1120              		@ link register save eliminated.
 1121 04c0 80B4     		push	{r7}
 1122              		.cfi_def_cfa_offset 4
 1123              		.cfi_offset 7, -4
 1124 04c2 85B0     		sub	sp, sp, #20
 1125              		.cfi_def_cfa_offset 24
 1126 04c4 00AF     		add	r7, sp, #0
 1127              		.cfi_def_cfa_register 7
 1128 04c6 7860     		str	r0, [r7, #4]
 941:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     tDMAControlTable *pControlTable;
 942:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     uint32_t ui32Control;
 943:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 944:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 945:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
 946:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 947:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
 948:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 949:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 950:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 951:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 952:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
 953:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // index from this parameter.
 954:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 955:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 1129              		.loc 1 955 0
 1130 04c8 7B68     		ldr	r3, [r7, #4]
 1131 04ca 03F03F03 		and	r3, r3, #63
 1132 04ce 7B60     		str	r3, [r7, #4]
 956:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 957:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 958:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get the base address of the control table.
 959:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 960:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 1133              		.loc 1 960 0
 1134 04d0 0C4B     		ldr	r3, .L82
 1135 04d2 1B68     		ldr	r3, [r3]
 1136 04d4 FB60     		str	r3, [r7, #12]
 961:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 962:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 963:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get the current control word value and mask off all but the size field
 964:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // and the mode field.
 965:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 966:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32Control = (pControlTable[ui32ChannelStructIndex].ui32Control &
 1137              		.loc 1 966 0
 1138 04d6 7B68     		ldr	r3, [r7, #4]
 1139 04d8 1B01     		lsls	r3, r3, #4
 1140 04da FA68     		ldr	r2, [r7, #12]
 1141 04dc 1344     		add	r3, r3, r2
 1142 04de 9A68     		ldr	r2, [r3, #8]
 1143 04e0 43F6F773 		movw	r3, #16375
 1144 04e4 1340     		ands	r3, r3, r2
 1145 04e6 BB60     		str	r3, [r7, #8]
 967:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                    (UDMACHCTL_CHCTL_XFERSIZE_M | UDMACHCTL_CHCTL_XFERMODE_M));
 968:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 969:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 970:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // If the size field and mode field are 0 then the transfer is finished
 971:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // and there are no more items to transfer
 972:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 973:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(ui32Control == 0)
 1146              		.loc 1 973 0
 1147 04e8 BB68     		ldr	r3, [r7, #8]
 1148 04ea 002B     		cmp	r3, #0
 1149 04ec 01D1     		bne	.L80
 974:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 975:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         return(0);
 1150              		.loc 1 975 0
 1151 04ee 0023     		movs	r3, #0
 1152 04f0 02E0     		b	.L81
 1153              	.L80:
 976:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 977:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 978:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 979:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Otherwise, if either the size field or more field is non-zero, then
 980:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // not all the items have been transferred.
 981:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
 982:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     else
 983:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
 984:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         //
 985:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         // Shift the size field and add one, then return to user.
 986:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         //
 987:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         return((ui32Control >> 4) + 1);
 1154              		.loc 1 987 0
 1155 04f2 BB68     		ldr	r3, [r7, #8]
 1156 04f4 1B09     		lsrs	r3, r3, #4
 1157 04f6 0133     		adds	r3, r3, #1
 1158              	.L81:
 988:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
 989:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 1159              		.loc 1 989 0
 1160 04f8 1846     		mov	r0, r3
 1161 04fa 1437     		adds	r7, r7, #20
 1162              		.cfi_def_cfa_offset 4
 1163 04fc BD46     		mov	sp, r7
 1164              		.cfi_def_cfa_register 13
 1165              		@ sp needed
 1166 04fe 80BC     		pop	{r7}
 1167              		.cfi_restore 7
 1168              		.cfi_def_cfa_offset 0
 1169 0500 7047     		bx	lr
 1170              	.L83:
 1171 0502 00BF     		.align	2
 1172              	.L82:
 1173 0504 08F00F40 		.word	1074786312
 1174              		.cfi_endproc
 1175              	.LFE17:
 1177              		.align	2
 1178              		.global	uDMAChannelModeGet
 1179              		.thumb
 1180              		.thumb_func
 1182              	uDMAChannelModeGet:
 1183              	.LFB18:
 990:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
 991:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
 992:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
 993:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Gets the transfer mode for a uDMA channel control structure
 994:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 995:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 996:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 997:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
 998:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function is used to get the transfer mode for the uDMA channel.  It
 999:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! can be used to query the status of a transfer on a channel.  When the
1000:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! transfer is complete the mode will be \b UDMA_MODE_STOP.
1001:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1002:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return Returns the transfer mode of the specified channel and control
1003:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! structure, which will be one of the following values: \b UDMA_MODE_STOP,
1004:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \b UDMA_MODE_BASIC, \b UDMA_MODE_AUTO, \b UDMA_MODE_PINGPONG,
1005:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \b UDMA_MODE_MEM_SCATTER_GATHER, or \b UDMA_MODE_PER_SCATTER_GATHER.
1006:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
1007:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
1008:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uint32_t
1009:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelModeGet(uint32_t ui32ChannelStructIndex)
1010:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 1184              		.loc 1 1010 0
 1185              		.cfi_startproc
 1186              		@ args = 0, pretend = 0, frame = 16
 1187              		@ frame_needed = 1, uses_anonymous_args = 0
 1188              		@ link register save eliminated.
 1189 0508 80B4     		push	{r7}
 1190              		.cfi_def_cfa_offset 4
 1191              		.cfi_offset 7, -4
 1192 050a 85B0     		sub	sp, sp, #20
 1193              		.cfi_def_cfa_offset 24
 1194 050c 00AF     		add	r7, sp, #0
 1195              		.cfi_def_cfa_register 7
 1196 050e 7860     		str	r0, [r7, #4]
1011:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     tDMAControlTable *pControlTable;
1012:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     uint32_t ui32Control;
1013:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1014:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1015:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
1016:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1017:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
1018:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
1019:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1020:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1021:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
1022:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
1023:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // index from this parameter.
1024:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1025:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 1197              		.loc 1 1025 0
 1198 0510 7B68     		ldr	r3, [r7, #4]
 1199 0512 03F03F03 		and	r3, r3, #63
 1200 0516 7B60     		str	r3, [r7, #4]
1026:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1027:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1028:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get the base address of the control table.
1029:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1030:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 1201              		.loc 1 1030 0
 1202 0518 0F4B     		ldr	r3, .L88
 1203 051a 1B68     		ldr	r3, [r3]
 1204 051c BB60     		str	r3, [r7, #8]
1031:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1032:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1033:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Get the current control word value and mask off all but the mode field.
1034:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1035:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32Control = (pControlTable[ui32ChannelStructIndex].ui32Control &
 1205              		.loc 1 1035 0
 1206 051e 7B68     		ldr	r3, [r7, #4]
 1207 0520 1B01     		lsls	r3, r3, #4
 1208 0522 BA68     		ldr	r2, [r7, #8]
 1209 0524 1344     		add	r3, r3, r2
 1210 0526 9B68     		ldr	r3, [r3, #8]
 1211 0528 03F00703 		and	r3, r3, #7
 1212 052c FB60     		str	r3, [r7, #12]
1036:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                    UDMACHCTL_CHCTL_XFERMODE_M);
1037:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1038:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1039:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check if scatter/gather mode, and if so, mask off the alt bit.
1040:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1041:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     if(((ui32Control & ~UDMA_MODE_ALT_SELECT) == UDMA_MODE_MEM_SCATTER_GATHER) ||
 1213              		.loc 1 1041 0
 1214 052e FB68     		ldr	r3, [r7, #12]
 1215 0530 23F00103 		bic	r3, r3, #1
 1216 0534 042B     		cmp	r3, #4
 1217 0536 04D0     		beq	.L85
1042:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             ((ui32Control & ~UDMA_MODE_ALT_SELECT) == UDMA_MODE_PER_SCATTER_GATHER))
 1218              		.loc 1 1042 0 discriminator 1
 1219 0538 FB68     		ldr	r3, [r7, #12]
 1220 053a 23F00103 		bic	r3, r3, #1
1041:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****             ((ui32Control & ~UDMA_MODE_ALT_SELECT) == UDMA_MODE_PER_SCATTER_GATHER))
 1221              		.loc 1 1041 0 discriminator 1
 1222 053e 062B     		cmp	r3, #6
 1223 0540 03D1     		bne	.L86
 1224              	.L85:
1043:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     {
1044:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****         ui32Control &= ~UDMA_MODE_ALT_SELECT;
 1225              		.loc 1 1044 0
 1226 0542 FB68     		ldr	r3, [r7, #12]
 1227 0544 23F00103 		bic	r3, r3, #1
 1228 0548 FB60     		str	r3, [r7, #12]
 1229              	.L86:
1045:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     }
1046:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1047:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1048:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Return the mode to the caller.
1049:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1050:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     return(ui32Control);
 1230              		.loc 1 1050 0
 1231 054a FB68     		ldr	r3, [r7, #12]
1051:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 1232              		.loc 1 1051 0
 1233 054c 1846     		mov	r0, r3
 1234 054e 1437     		adds	r7, r7, #20
 1235              		.cfi_def_cfa_offset 4
 1236 0550 BD46     		mov	sp, r7
 1237              		.cfi_def_cfa_register 13
 1238              		@ sp needed
 1239 0552 80BC     		pop	{r7}
 1240              		.cfi_restore 7
 1241              		.cfi_def_cfa_offset 0
 1242 0554 7047     		bx	lr
 1243              	.L89:
 1244 0556 00BF     		.align	2
 1245              	.L88:
 1246 0558 08F00F40 		.word	1074786312
 1247              		.cfi_endproc
 1248              	.LFE18:
 1250              		.align	2
 1251              		.global	uDMAIntRegister
 1252              		.thumb
 1253              		.thumb_func
 1255              	uDMAIntRegister:
 1256              	.LFB19:
1052:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1053:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1054:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
1055:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
1056:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Registers an interrupt handler for the uDMA controller
1057:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1058:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32IntChannel identifies which uDMA interrupt is to be registered.
1059:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param pfnHandler is a pointer to the function to be called when the
1060:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! interrupt is activated.
1061:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1062:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This sets and enables the handler to be called when the uDMA controller
1063:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! generates an interrupt.  The \e ui32IntChannel parameter should be one of the
1064:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! following:
1065:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1066:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_INT_SW to register an interrupt handler to process interrupts
1067:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   from the uDMA software channel (UDMA_CH30_SW)
1068:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! - \b UDMA_INT_ERR to register an interrupt handler to process uDMA error
1069:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!   interrupts
1070:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1071:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \sa IntRegister() for important information about registering interrupt
1072:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! handlers.
1073:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1074:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \note The interrupt handler for uDMA is for transfer completion when the
1075:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! channel UDMA_CH30W is used, and for error interrupts.  The
1076:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! interrupts for each peripheral channel are handled through the individual
1077:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! peripheral interrupt handlers.
1078:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1079:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
1080:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
1081:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
1082:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
1083:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAIntRegister(uint32_t ui32IntChannel, void (*pfnHandler)(void))
1084:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 1257              		.loc 1 1084 0
 1258              		.cfi_startproc
 1259              		@ args = 0, pretend = 0, frame = 8
 1260              		@ frame_needed = 1, uses_anonymous_args = 0
 1261 055c 80B5     		push	{r7, lr}
 1262              		.cfi_def_cfa_offset 8
 1263              		.cfi_offset 7, -8
 1264              		.cfi_offset 14, -4
 1265 055e 82B0     		sub	sp, sp, #8
 1266              		.cfi_def_cfa_offset 16
 1267 0560 00AF     		add	r7, sp, #0
 1268              		.cfi_def_cfa_register 7
 1269 0562 7860     		str	r0, [r7, #4]
 1270 0564 3960     		str	r1, [r7]
1085:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1086:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the arguments.
1087:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1088:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT(pfnHandler);
1089:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32IntChannel == UDMA_INT_SW) || (ui32IntChannel == UDMA_INT_ERR));
1090:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1091:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1092:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Register the interrupt handler.
1093:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1094:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     IntRegister(ui32IntChannel, pfnHandler);
 1271              		.loc 1 1094 0
 1272 0566 3968     		ldr	r1, [r7]
 1273 0568 7868     		ldr	r0, [r7, #4]
 1274 056a FFF7FEFF 		bl	IntRegister
1095:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1096:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1097:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Enable the memory management fault.
1098:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1099:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     IntEnable(ui32IntChannel);
 1275              		.loc 1 1099 0
 1276 056e 7868     		ldr	r0, [r7, #4]
 1277 0570 FFF7FEFF 		bl	IntEnable
1100:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 1278              		.loc 1 1100 0
 1279 0574 00BF     		nop
 1280 0576 0837     		adds	r7, r7, #8
 1281              		.cfi_def_cfa_offset 8
 1282 0578 BD46     		mov	sp, r7
 1283              		.cfi_def_cfa_register 13
 1284              		@ sp needed
 1285 057a 80BD     		pop	{r7, pc}
 1286              		.cfi_endproc
 1287              	.LFE19:
 1289              		.align	2
 1290              		.global	uDMAIntUnregister
 1291              		.thumb
 1292              		.thumb_func
 1294              	uDMAIntUnregister:
 1295              	.LFB20:
1101:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1102:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
1103:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
1104:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Unregisters an interrupt handler for the uDMA controller
1105:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1106:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32IntChannel identifies which uDMA interrupt to unregister.
1107:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1108:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function will disable and clear the handler to be called for the
1109:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! specified uDMA interrupt.  The \e ui32IntChannel parameter should be one of
1110:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \b UDMA_INT_SW or \b UDMA_INT_ERR as documented for the function
1111:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! uDMAIntRegister().
1112:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1113:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \sa IntRegister() for important information about registering interrupt
1114:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! handlers.
1115:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1116:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
1117:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
1118:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
1119:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
1120:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAIntUnregister(uint32_t ui32IntChannel)
1121:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 1296              		.loc 1 1121 0
 1297              		.cfi_startproc
 1298              		@ args = 0, pretend = 0, frame = 8
 1299              		@ frame_needed = 1, uses_anonymous_args = 0
 1300 057c 80B5     		push	{r7, lr}
 1301              		.cfi_def_cfa_offset 8
 1302              		.cfi_offset 7, -8
 1303              		.cfi_offset 14, -4
 1304 057e 82B0     		sub	sp, sp, #8
 1305              		.cfi_def_cfa_offset 16
 1306 0580 00AF     		add	r7, sp, #0
 1307              		.cfi_def_cfa_register 7
 1308 0582 7860     		str	r0, [r7, #4]
1122:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1123:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Disable the interrupt.
1124:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1125:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     IntDisable(ui32IntChannel);
 1309              		.loc 1 1125 0
 1310 0584 7868     		ldr	r0, [r7, #4]
 1311 0586 FFF7FEFF 		bl	IntDisable
1126:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1127:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1128:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Unregister the interrupt handler.
1129:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1130:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     IntUnregister(ui32IntChannel);
 1312              		.loc 1 1130 0
 1313 058a 7868     		ldr	r0, [r7, #4]
 1314 058c FFF7FEFF 		bl	IntUnregister
1131:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 1315              		.loc 1 1131 0
 1316 0590 00BF     		nop
 1317 0592 0837     		adds	r7, r7, #8
 1318              		.cfi_def_cfa_offset 8
 1319 0594 BD46     		mov	sp, r7
 1320              		.cfi_def_cfa_register 13
 1321              		@ sp needed
 1322 0596 80BD     		pop	{r7, pc}
 1323              		.cfi_endproc
 1324              	.LFE20:
 1326              		.align	2
 1327              		.global	uDMAIntStatus
 1328              		.thumb
 1329              		.thumb_func
 1331              	uDMAIntStatus:
 1332              	.LFB21:
1132:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1133:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
1134:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
1135:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Gets the uDMA controller channel interrupt status
1136:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1137:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function is used to get the interrupt status of the uDMA controller.
1138:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! The returned value is a 32-bit bit mask that indicates which channels are
1139:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! requesting an interrupt.  This function can be used from within an
1140:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! interrupt handler to determine or confirm which uDMA channel has requested
1141:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! an interrupt.
1142:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1143:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \note This function is only available on devices that have the DMA Channel
1144:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Interrupt Status Register (DMACHIS).  Please consult the data sheet for
1145:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! your part.
1146:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1147:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return Returns a 32-bit mask which indicates requesting uDMA channels.
1148:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! There is a bit for each channel, and a 1 in a bit indicates that channel
1149:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! is requesting an interrupt.  Multiple bits can be set.
1150:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
1151:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
1152:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uint32_t
1153:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAIntStatus(void)
1154:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 1333              		.loc 1 1154 0
 1334              		.cfi_startproc
 1335              		@ args = 0, pretend = 0, frame = 0
 1336              		@ frame_needed = 1, uses_anonymous_args = 0
 1337              		@ link register save eliminated.
 1338 0598 80B4     		push	{r7}
 1339              		.cfi_def_cfa_offset 4
 1340              		.cfi_offset 7, -4
 1341 059a 00AF     		add	r7, sp, #0
 1342              		.cfi_def_cfa_register 7
1155:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1156:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Return the value of the uDMA interrupt status register
1157:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1158:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     return(HWREG(UDMA_CHIS));
 1343              		.loc 1 1158 0
 1344 059c 024B     		ldr	r3, .L94
 1345 059e 1B68     		ldr	r3, [r3]
1159:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 1346              		.loc 1 1159 0
 1347 05a0 1846     		mov	r0, r3
 1348 05a2 BD46     		mov	sp, r7
 1349              		.cfi_def_cfa_register 13
 1350              		@ sp needed
 1351 05a4 80BC     		pop	{r7}
 1352              		.cfi_restore 7
 1353              		.cfi_def_cfa_offset 0
 1354 05a6 7047     		bx	lr
 1355              	.L95:
 1356              		.align	2
 1357              	.L94:
 1358 05a8 04F50F40 		.word	1074787588
 1359              		.cfi_endproc
 1360              	.LFE21:
 1362              		.align	2
 1363              		.global	uDMAIntClear
 1364              		.thumb
 1365              		.thumb_func
 1367              	uDMAIntClear:
 1368              	.LFB22:
1160:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1161:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
1162:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
1163:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Clears uDMA interrupt status
1164:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1165:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32ChanMask is a 32-bit mask with one bit for each uDMA channel.
1166:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1167:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Clears bits in the uDMA interrupt status register according to which bits
1168:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! are set in \e ui32ChanMask. There is one bit for each channel. If a a bit
1169:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! is set in \e ui32ChanMask, then that corresponding channel's interrupt
1170:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! status will be cleared (if it was set).
1171:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1172:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \note This function is only available on devices that have the DMA Channel
1173:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Interrupt Status Register (DMACHIS).  Please consult the data sheet for
1174:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! your part.
1175:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1176:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
1177:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
1178:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
1179:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
1180:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAIntClear(uint32_t ui32ChanMask)
1181:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 1369              		.loc 1 1181 0
 1370              		.cfi_startproc
 1371              		@ args = 0, pretend = 0, frame = 8
 1372              		@ frame_needed = 1, uses_anonymous_args = 0
 1373              		@ link register save eliminated.
 1374 05ac 80B4     		push	{r7}
 1375              		.cfi_def_cfa_offset 4
 1376              		.cfi_offset 7, -4
 1377 05ae 83B0     		sub	sp, sp, #12
 1378              		.cfi_def_cfa_offset 16
 1379 05b0 00AF     		add	r7, sp, #0
 1380              		.cfi_def_cfa_register 7
 1381 05b2 7860     		str	r0, [r7, #4]
1182:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1183:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Clear the requested bits in the uDMA interrupt status register
1184:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1185:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     HWREG(UDMA_CHIS) = ui32ChanMask;
 1382              		.loc 1 1185 0
 1383 05b4 034A     		ldr	r2, .L97
 1384 05b6 7B68     		ldr	r3, [r7, #4]
 1385 05b8 1360     		str	r3, [r2]
1186:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 1386              		.loc 1 1186 0
 1387 05ba 00BF     		nop
 1388 05bc 0C37     		adds	r7, r7, #12
 1389              		.cfi_def_cfa_offset 4
 1390 05be BD46     		mov	sp, r7
 1391              		.cfi_def_cfa_register 13
 1392              		@ sp needed
 1393 05c0 80BC     		pop	{r7}
 1394              		.cfi_restore 7
 1395              		.cfi_def_cfa_offset 0
 1396 05c2 7047     		bx	lr
 1397              	.L98:
 1398              		.align	2
 1399              	.L97:
 1400 05c4 04F50F40 		.word	1074787588
 1401              		.cfi_endproc
 1402              	.LFE22:
 1404              		.align	2
 1405              		.global	uDMAChannelAssign
 1406              		.thumb
 1407              		.thumb_func
 1409              	uDMAChannelAssign:
 1410              	.LFB23:
1187:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1188:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
1189:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
1190:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Assigns a peripheral mapping for a uDMA channel
1191:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1192:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \param ui32Mapping is a macro specifying the peripheral assignment for
1193:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! a channel
1194:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1195:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! This function assigns a peripheral mapping to a uDMA channel.  It is
1196:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! used to select which peripheral is used for a uDMA channel.  The parameter
1197:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \e ui32Mapping should be one of the macros named \b UDMA_CHn_tttt from the
1198:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! header file \e udma.h.  For example, to assign uDMA channel 8 to the
1199:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! UART0RX channel, the parameter should be the macro \b UDMA_CH8_UART0RX.
1200:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1201:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Please consult the cc2538 data sheet for a table showing all the
1202:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! possible peripheral assignments for the uDMA channels for a particular
1203:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! device.
1204:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1205:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \note This function is only available on devices that have the DMA Channel
1206:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! Map Select registers (DMACHMAP0-3).  Please consult the data sheet for
1207:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! your part.
1208:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //!
1209:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //! \return None
1210:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //
1211:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** //*****************************************************************************
1212:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** void
1213:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** uDMAChannelAssign(uint32_t ui32Mapping)
1214:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** {
 1411              		.loc 1 1214 0
 1412              		.cfi_startproc
 1413              		@ args = 0, pretend = 0, frame = 24
 1414              		@ frame_needed = 1, uses_anonymous_args = 0
 1415              		@ link register save eliminated.
 1416 05c8 80B4     		push	{r7}
 1417              		.cfi_def_cfa_offset 4
 1418              		.cfi_offset 7, -4
 1419 05ca 87B0     		sub	sp, sp, #28
 1420              		.cfi_def_cfa_offset 32
 1421 05cc 00AF     		add	r7, sp, #0
 1422              		.cfi_def_cfa_register 7
 1423 05ce 7860     		str	r0, [r7, #4]
1215:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     uint32_t ui32MapReg;
1216:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     uint32_t ui32MapShift;
1217:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     uint32_t ui32ChannelNum;
1218:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     uint32_t ui32Encoding;
1219:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1220:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1221:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Check the parameters
1222:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1223:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ASSERT((ui32Mapping & 0xffffff00) < 0x00050000);
1224:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1225:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1226:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Extract the channel number and map encoding value from the parameter.
1227:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1228:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32ChannelNum = ui32Mapping & 0xff;
 1424              		.loc 1 1228 0
 1425 05d0 7B68     		ldr	r3, [r7, #4]
 1426 05d2 DBB2     		uxtb	r3, r3
 1427 05d4 7B61     		str	r3, [r7, #20]
1229:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32Encoding   = ui32Mapping >> 16;
 1428              		.loc 1 1229 0
 1429 05d6 7B68     		ldr	r3, [r7, #4]
 1430 05d8 1B0C     		lsrs	r3, r3, #16
 1431 05da 3B61     		str	r3, [r7, #16]
1230:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1231:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1232:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Find the uDMA channel mapping register and shift value to use for this
1233:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // channel
1234:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1235:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32MapReg = UDMA_CHMAP0 + ((ui32ChannelNum / 8) * 4);
 1432              		.loc 1 1235 0
 1433 05dc 7B69     		ldr	r3, [r7, #20]
 1434 05de DA08     		lsrs	r2, r3, #3
 1435 05e0 0E4B     		ldr	r3, .L100
 1436 05e2 1344     		add	r3, r3, r2
 1437 05e4 9B00     		lsls	r3, r3, #2
 1438 05e6 FB60     		str	r3, [r7, #12]
1236:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     ui32MapShift = (ui32ChannelNum % 8) * 4;
 1439              		.loc 1 1236 0
 1440 05e8 7B69     		ldr	r3, [r7, #20]
 1441 05ea 03F00703 		and	r3, r3, #7
 1442 05ee 9B00     		lsls	r3, r3, #2
 1443 05f0 BB60     		str	r3, [r7, #8]
1237:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** 
1238:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1239:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     // Set the channel map encoding for this channel
1240:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     //
1241:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****     HWREG(ui32MapReg) = (HWREG(ui32MapReg) & ~(0xf << ui32MapShift)) |
 1444              		.loc 1 1241 0
 1445 05f2 FB68     		ldr	r3, [r7, #12]
 1446 05f4 FA68     		ldr	r2, [r7, #12]
 1447 05f6 1268     		ldr	r2, [r2]
 1448 05f8 0F20     		movs	r0, #15
 1449 05fa B968     		ldr	r1, [r7, #8]
 1450 05fc 00FA01F1 		lsl	r1, r0, r1
 1451 0600 C943     		mvns	r1, r1
 1452 0602 1140     		ands	r1, r1, r2
1242:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                         ui32Encoding << ui32MapShift;
 1453              		.loc 1 1242 0
 1454 0604 3869     		ldr	r0, [r7, #16]
 1455 0606 BA68     		ldr	r2, [r7, #8]
 1456 0608 00FA02F2 		lsl	r2, r0, r2
1241:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c ****                         ui32Encoding << ui32MapShift;
 1457              		.loc 1 1241 0
 1458 060c 0A43     		orrs	r2, r2, r1
 1459 060e 1A60     		str	r2, [r3]
1243:build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.c **** }
 1460              		.loc 1 1243 0
 1461 0610 00BF     		nop
 1462 0612 1C37     		adds	r7, r7, #28
 1463              		.cfi_def_cfa_offset 4
 1464 0614 BD46     		mov	sp, r7
 1465              		.cfi_def_cfa_register 13
 1466              		@ sp needed
 1467 0616 80BC     		pop	{r7}
 1468              		.cfi_restore 7
 1469              		.cfi_def_cfa_offset 0
 1470 0618 7047     		bx	lr
 1471              	.L101:
 1472 061a 00BF     		.align	2
 1473              	.L100:
 1474 061c 44FD0310 		.word	268696900
 1475              		.cfi_endproc
 1476              	.LFE23:
 1478              	.Letext0:
 1479              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1480              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 1481              		.file 4 "build/openmote-cc2538_armgcc/bsp/boards/openmote-cc2538/source/udma.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 udma.c
     /tmp/cchIGNyG.s:19     .text:0000000000000000 $t
     /tmp/cchIGNyG.s:24     .text:0000000000000000 uDMAEnable
     /tmp/cchIGNyG.s:53     .text:0000000000000014 $d
     /tmp/cchIGNyG.s:57     .text:0000000000000018 $t
     /tmp/cchIGNyG.s:62     .text:0000000000000018 uDMADisable
     /tmp/cchIGNyG.s:90     .text:000000000000002c $d
     /tmp/cchIGNyG.s:94     .text:0000000000000030 $t
     /tmp/cchIGNyG.s:99     .text:0000000000000030 uDMAErrorStatusGet
     /tmp/cchIGNyG.s:126    .text:0000000000000040 $d
     /tmp/cchIGNyG.s:130    .text:0000000000000044 $t
     /tmp/cchIGNyG.s:135    .text:0000000000000044 uDMAErrorStatusClear
     /tmp/cchIGNyG.s:163    .text:0000000000000058 $d
     /tmp/cchIGNyG.s:167    .text:000000000000005c $t
     /tmp/cchIGNyG.s:172    .text:000000000000005c uDMAChannelEnable
     /tmp/cchIGNyG.s:208    .text:0000000000000080 $d
     /tmp/cchIGNyG.s:212    .text:0000000000000084 $t
     /tmp/cchIGNyG.s:217    .text:0000000000000084 uDMAChannelDisable
     /tmp/cchIGNyG.s:253    .text:00000000000000a8 $d
     /tmp/cchIGNyG.s:257    .text:00000000000000ac $t
     /tmp/cchIGNyG.s:262    .text:00000000000000ac uDMAChannelIsEnabled
     /tmp/cchIGNyG.s:304    .text:00000000000000dc $d
     /tmp/cchIGNyG.s:308    .text:00000000000000e0 $t
     /tmp/cchIGNyG.s:313    .text:00000000000000e0 uDMAControlBaseSet
     /tmp/cchIGNyG.s:346    .text:00000000000000f8 $d
     /tmp/cchIGNyG.s:350    .text:00000000000000fc $t
     /tmp/cchIGNyG.s:355    .text:00000000000000fc uDMAControlBaseGet
     /tmp/cchIGNyG.s:382    .text:000000000000010c $d
     /tmp/cchIGNyG.s:386    .text:0000000000000110 $t
     /tmp/cchIGNyG.s:391    .text:0000000000000110 uDMAControlAlternateBaseGet
     /tmp/cchIGNyG.s:418    .text:0000000000000120 $d
     /tmp/cchIGNyG.s:422    .text:0000000000000124 $t
     /tmp/cchIGNyG.s:427    .text:0000000000000124 uDMAChannelRequest
     /tmp/cchIGNyG.s:463    .text:0000000000000148 $d
     /tmp/cchIGNyG.s:467    .text:000000000000014c $t
     /tmp/cchIGNyG.s:472    .text:000000000000014c uDMAChannelAttributeEnable
     /tmp/cchIGNyG.s:554    .text:00000000000001c0 $d
     /tmp/cchIGNyG.s:561    .text:00000000000001d0 $t
     /tmp/cchIGNyG.s:566    .text:00000000000001d0 uDMAChannelAttributeDisable
     /tmp/cchIGNyG.s:648    .text:0000000000000244 $d
     /tmp/cchIGNyG.s:655    .text:0000000000000254 $t
     /tmp/cchIGNyG.s:660    .text:0000000000000254 uDMAChannelAttributeGet
     /tmp/cchIGNyG.s:754    .text:00000000000002dc $d
     /tmp/cchIGNyG.s:761    .text:00000000000002ec $t
     /tmp/cchIGNyG.s:766    .text:00000000000002ec uDMAChannelControlSet
     /tmp/cchIGNyG.s:822    .text:000000000000032c $d
     /tmp/cchIGNyG.s:827    .text:0000000000000334 $t
     /tmp/cchIGNyG.s:832    .text:0000000000000334 uDMAChannelTransferSet
     /tmp/cchIGNyG.s:998    .text:0000000000000434 $d
     /tmp/cchIGNyG.s:1002   .text:0000000000000438 $t
     /tmp/cchIGNyG.s:1007   .text:0000000000000438 uDMAChannelScatterGatherSet
     /tmp/cchIGNyG.s:1105   .text:00000000000004bc $d
     /tmp/cchIGNyG.s:1109   .text:00000000000004c0 $t
     /tmp/cchIGNyG.s:1114   .text:00000000000004c0 uDMAChannelSizeGet
     /tmp/cchIGNyG.s:1173   .text:0000000000000504 $d
     /tmp/cchIGNyG.s:1177   .text:0000000000000508 $t
     /tmp/cchIGNyG.s:1182   .text:0000000000000508 uDMAChannelModeGet
     /tmp/cchIGNyG.s:1246   .text:0000000000000558 $d
     /tmp/cchIGNyG.s:1250   .text:000000000000055c $t
     /tmp/cchIGNyG.s:1255   .text:000000000000055c uDMAIntRegister
     /tmp/cchIGNyG.s:1294   .text:000000000000057c uDMAIntUnregister
     /tmp/cchIGNyG.s:1331   .text:0000000000000598 uDMAIntStatus
     /tmp/cchIGNyG.s:1358   .text:00000000000005a8 $d
     /tmp/cchIGNyG.s:1362   .text:00000000000005ac $t
     /tmp/cchIGNyG.s:1367   .text:00000000000005ac uDMAIntClear
     /tmp/cchIGNyG.s:1400   .text:00000000000005c4 $d
     /tmp/cchIGNyG.s:1404   .text:00000000000005c8 $t
     /tmp/cchIGNyG.s:1409   .text:00000000000005c8 uDMAChannelAssign
     /tmp/cchIGNyG.s:1474   .text:000000000000061c $d
                     .debug_frame:0000000000000010 $d
                           .group:0000000000000000 wm4.0.8e445c0106ab795ab4704214cba6f089
                           .group:0000000000000000 wm4.hw_sys_ctrl.h.39.50b4d7775c38e82076d0eb3bdc2daf82
                           .group:0000000000000000 wm4.hw_udma.h.39.264bcf912c9ca2a6a4c20ac52cfd6e50
                           .group:0000000000000000 wm4.hw_udmachctl.h.39.691b4def60389db06f6fa18129325381
                           .group:0000000000000000 wm4._newlib_version.h.4.ad342815780c8db09778091a421b5b5b
                           .group:0000000000000000 wm4.features.h.33.d97f2d646536517df901beeb5b9993f5
                           .group:0000000000000000 wm4._default_types.h.15.933e8edd27a65e0b69af4a865eb623d2
                           .group:0000000000000000 wm4._intsup.h.10.b82bf99f69d6a5c085fc866de0d3eb9b
                           .group:0000000000000000 wm4._stdint.h.10.7a5f60e6741af4a5594a3867d347e1f9
                           .group:0000000000000000 wm4.stdint.h.23.373a9d32a9e4c2e88fd347156532d281
                           .group:0000000000000000 wm4.stdbool.h.29.07dce69c3b78884144b7f7bd19483461
                           .group:0000000000000000 wm4.hw_types.h.67.b10589a0806dcc2d274d6fab6b736519
                           .group:0000000000000000 wm4.interrupt.h.41.272fc4ec0e276feb439e7974d0f77eaf
                           .group:0000000000000000 wm4.udma.h.41.9638b4921f2086b7874ec413c0bf6e00

UNDEFINED SYMBOLS
IntRegister
IntEnable
IntDisable
IntUnregister
